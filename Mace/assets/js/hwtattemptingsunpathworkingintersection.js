// Start Main IIFE to encapsulate the entire combined script and prevent global scope conflicts
(function() {
    // The top-level initialization guard (window.MaceHWTCalculatorInitialized) has been removed.
    // This ensures the script runs fully upon each execution/load, as per your instruction.

    const HWT_HORIZONE_SRC = "K52"; // Specific source ID from horiZONE.html example

    // --- Console Output Override ---
    const originalConsole = { // Capture original console methods
        log: console.log,
        warn: console.warn,
        error: console.error
    };

    // Re-assign console.log/warn/error to use the global displayMessage if needed for consistency
    // Fully re-enable original console logging for direct calls for debugging.
    console.log = function(...args) {
        originalConsole.log(...args);
        // Do NOT route to window.displayMessage here, as it's for specific UI elements.
    };
    console.warn = function(...args) {
        originalConsole.warn(...args);
        // Do NOT route to window.displayMessage here.
    };
    console.error = function(...args) {
        originalConsole.error(...args);
        // Do NOT route to window.displayMessage here.
    };

    // Expose displayMessage and clearResultsDisplay globally for the new export/import script
    window.displayMessage = function(elementId, message, type = 'status') {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = message;
            element.className = `status-message ${type}-message`; // Apply Tailwind classes for styling
        }
        // Log to original console for debugging purposes, but only for explicit displayMessage calls
        originalConsole.log(`Display Message [${type}] for ${elementId || 'N/A'}: ${message}`);
    };


    // --- Leaflet Map and Layer Variables (now referencing global objects from Script B) ---
    // These variables will be assigned from window.map and window.layersControl
    // when the DOM is ready and Script B has initialized them.
    let map = null;
    let layersControl = null;
    let observerMarker = null; // This will now be Script C's own L.CircleMarker

    // Array to hold all LayerGroups created by Script C for easy clearing and GeoJSON export
    // Expose scriptCOverlayGroups globally for the new export/import script
    window.scriptCOverlayGroups = [];

    // Global layer variables for orthodrome and intersection (reintroduced)
    let ssrOrthodromeLine = null;
    let ssrOrthodromeEndPointMarker = null;
    let ssrIntersectionMarker = null; // This will now hold the actual marker, not the layer group
    let ssrIntersectionLayerGroup = null; // New: LayerGroup for the intersection marker

    /**
     * Clears all dynamically added overlay layers from the map that were generated by Script C.
     * This function now specifically targets layer groups managed by Script C.
     */
    window.clearResultsDisplay = function() { // Made global
        // Iterate over layer groups created by window.scriptCOverlayGroups and remove them
        window.scriptCOverlayGroups.forEach(layerGroup => {
            if (window.map && window.map.hasLayer(layerGroup)) {
                window.map.removeLayer(layerGroup);
            }
            // Remove from layers control if it was added there
            if (window.layersControl && layerGroup.layerNameForControl) {
                window.layersControl.removeLayer(layerGroup);
            }
        });
        // Clear the array of Script C's layer groups
        window.scriptCOverlayGroups = [];

        // Also explicitly clear the orthodrome and intersection layers if they exist
        // Note: ssrIntersectionLayerGroup is now managed by scriptCOverlayGroups, so its explicit removal is redundant here.
        if (map && layersControl) {
            if (ssrOrthodromeLine && map.hasLayer(ssrOrthodromeLine)) {
                map.removeLayer(ssrOrthodromeLine);
                layersControl.removeLayer(ssrOrthodromeLine);
            }
            if (ssrOrthodromeEndPointMarker && map.hasLayer(ssrOrthodromeEndPointMarker)) {
                map.removeLayer(ssrOrthodromeEndPointMarker);
                layersControl.removeLayer(ssrOrthodromeEndPointMarker);
            }
        }
        ssrOrthodromeLine = null;
        ssrOrthodromeEndPointMarker = null;
        ssrIntersectionMarker = null; // Reset the marker reference
        ssrIntersectionLayerGroup = null; // Reset the layer group reference
    };

    // --- Astronomical Constants ---
    // These are standard apparent altitudes of the SUN'S CENTER relative to the GEOMETRIC HORIZON (0 degrees)
    // when different parts of the sun are at the horizon. They include average atmospheric refraction.
    const SOLAR_REFRACTION = 0.583; // Approx. refraction at horizon for Sun (degrees)
    const SOLAR_SEMIDIAMETER = 0.25; // Approx. semi-diameter of the Sun (degrees)

    // Exact azimuthal shift based on user's guidance for 1 degree for full disk (0.51 per semi-diameter)
    // This value is used to calculate the initial azimuth guesses for the center and lower limb,
    // reflecting the horizontal spread of the sun's disk at a geometric horizon.
    const AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT = 0.51; // degrees of azimuth for one solar semi-diameter's worth of altitude change

    // Array of colors for future polygons
    const POLYGON_COLORS = ['orange', 'blue', 'red', 'yellow', 'green'];

    /**
     * Generates points for an orthodrome (great circle path) between a start point and an end point.
     * Overloaded to work from two points or from a start point, bearing, and distance.
     * Based on standard geodesic formulas (similar to Chris Veness's methods).
     * @param {number} lat1 - Start Latitude.
     * @param {number} lon1 - Start Longitude.
     * @param {number} lat2OrBearing - End Latitude OR Bearing in degrees.
     * @param {number} lon2OrDistanceKm - End Longitude OR Distance in kilometers.
     * @param {number} [numPoints=25] - Number of intermediate points to generate for smoothness.
     * @param {number} [bearing=undefined] - Bearing (if using start/bearing/distance overload).
     * @param {number} [distanceKm=undefined] - Distance (if using start/bearing/distance overload).
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for the orthodrome.
     */
    function generateOrthodromePoints(lat1, lon1, lat2OrBearing, lon2OrDistanceKm, numPoints = 25, bearing = undefined, distanceKm = undefined) {
        const points = [];
        points.push([lat1, lon1]);

        let endLat, endLon;
        let totalDistanceRad;

        const R = 6371; // Earth's radius in kilometers
        if (bearing !== undefined && distanceKm !== undefined) { // From start point, bearing, distance
            const brngRad = toRadians(bearing);
            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            totalDistanceRad = distanceKm / R;

            const latRad2 = Math.asin(Math.sin(latRad1) * Math.cos(totalDistanceRad) + Math.cos(latRad1) * Math.sin(totalDistanceRad) * Math.cos(brngRad));
            const lonRad2 = lonRad1 + Math.atan2(Math.sin(brngRad) * Math.sin(totalDistanceRad) * Math.cos(latRad1), Math.cos(totalDistanceRad) - Math.sin(latRad1) * Math.sin(latRad2));

            endLat = toDegrees(latRad2);
            endLon = toDegrees(lonRad2);
        } else { // From two points
            endLat = lat2OrBearing;
            endLon = lon2OrDistanceKm;

            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            const latRad2 = toRadians(endLat);
            const lonRad2 = toRadians(endLon);

            // Calculate angular distance for two points (Haversine-like for angular distance)
            const deltaLat = latRad2 - latRad1;
            const deltaLon = lonRad2 - lonRad1;
            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(latRad1) * Math.cos(latRad2) *
                Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
            totalDistanceRad = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        if (totalDistanceRad < 1e-6) { // Points are very close or identical
            points.push([endLat, endLon]);
            return points;
        }

        for (let i = 1; i < numPoints; i++) {
            const f = i / numPoints; // Fraction along the path
            const A = Math.sin((1 - f) * totalDistanceRad) / Math.sin(totalDistanceRad);
            const B = Math.sin(f * totalDistanceRad) / Math.sin(totalDistanceRad);

            const x = A * Math.cos(toRadians(lat1)) * Math.cos(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.cos(toRadians(endLon));
            const y = A * Math.cos(toRadians(lat1)) * Math.sin(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.sin(toRadians(lon2OrDistanceKm));
            const z = A * Math.sin(toRadians(lat1)) + B * Math.sin(toRadians(endLat));

            const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
            const lon = Math.atan2(y, x);

            points.push([toDegrees(lat), toDegrees(lon)]);
        }
        points.push([endLat, endLon]); // Ensure the exact endpoint is included
        return points;
    }

    /**
     * Interpolates horizon Lat/Lon for a given azimuth.
     * Finds the two horizon data points that bracket the target azimuth and performs linear interpolation.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {{lat: number, lon: number, azimuth: number}|null} Interpolated lat/lon with original azimuth, or null if cannot interpolate.
     */
    function getInterpolatedHorizonLatLon(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = window.normalizeAzimuth(azimuth); // Use window.normalizeAzimuth
        let p1 = null;
        let p2 = null;

        // To handle wrap-around, create an extended version of horizonData
        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        // Find the two horizon data points that bracket the target azimuth
        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            if (p2_az_for_interp === p1_az_for_interp) { // Avoid division by zero for vertical segments
                return { lat: p1.horizonLat, lon: p1.horizonLon, azimuth: azimuth };
            }

            const ratio = (targetAz_for_ratio - p1.altitude) / (p2.altitude - p1.altitude); // Interpolate based on azimuth here

            const interpolatedLat = p1.horizonLat + ratio * (p2.horizonLat - p1.horizonLat);
            const interpolatedLon = p1.horizonLon + ratio * (p2.horizonLon - p1.horizonLon);

            return { lat: interpolatedLat, lon: interpolatedLon, azimuth: azimuth };
        }
        return null;
    }

    /**
     * Interpolates and returns the altitude of the horizon for a given azimuth.
     * This function is crucial for the iterative search logic.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {number|null} The interpolated altitude, or null if cannot interpolate.
     */
    function getInterpolatedHorizonAltitude(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = window.normalizeAzimuth(azimuth);
        let p1 = null;
        let p2 = null;

        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            if (p2_az_for_interp === p1_az_for_interp) { // Avoid division by zero for vertical segments
                return p1.altitude;
            }

            const ratio = (targetAz_for_ratio - p1_az_for_interp) / (p2_az_for_interp - p1_az_for_interp);
            const interpolatedAltitude = p1.altitude + ratio * (p2.altitude - p1.altitude);
            return interpolatedAltitude;
        }
        return null;
    }

    /**
     * Collects horizon data points that lie azimuthally between two given azimuths,
     * always traversing in a *clockwise (increasing azimuth)* direction, handling 0/360 wrap-around.
     * The points are returned sorted by increasing azimuth.
     * @param {number} startAz - The starting azimuth of the segment (exclusive).
     * @param {number} endAz - The ending azimuth of the segment (exclusive).
     * @param {Array<Object>} horizonData - The full sorted horizon data.
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for points within the range, ordered by increasing azimuth.
     */
    function getIntermediateHorizonPoints(startAz, endAz, horizonData) {
        const points = [];
        if (!horizonData || horizonData.length === 0) {
            return points;
        }

        // Normalize start and end to be within 0-360 for initial range comparison
        const nStart = window.normalizeAzimuth(startAz); // Use window.normalizeAzimuth
        let nEnd = window.normalizeAzimuth(endAz); // Use window.normalizeAzimuth

        // If the intended clockwise range crosses 0/360 (e.g., from 350 to 10), adjust nEnd to be > nStart
        if (nStart > nEnd) {
            nEnd += 360; // Treat as 350 to 370 for comparison
        }

        // Create an extended version of horizonData with azimuths adjusted to cover the full 0-720 range
        // This simplifies range checking for wrapped segments.
        const extendedHorizonData = [];
        horizonData.forEach(p => {
            extendedHorizonData.push(p); // Original
            extendedHorizonData.push({ ...p, azimuth: p.azimuth + 360 }); // Add a +360 counterpart
        });
        // Sort the extended data to ensure iteration is always in increasing azimuth order
        extendedHorizonData.sort((a, b) => a.azimuth - b.azimuth);

        // Iterate through the extended, sorted data
        for (const point of extendedHorizonData) {
            const currentAz = point.azimuth;

            // Include points strictly between start and end (exclusive of endpoints)
            // Use a small tolerance for floating-point comparisons
            if (currentAz > nStart + 0.0001 && currentAz < nEnd - 0.0001) {
                if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                    points.push([point.horizonLat, point.horizonLon]);
                }
            }
        }
        return points;
    }

    /**
     * Draws the viewshed horizon as a polyline using provided lat/lon values.
     * @param {Array<Object>} horizonData - Array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @returns {L.Polyline|null} The created Leaflet Polyline object, or null if invalid data.
     */
    function drawViewshedHorizonLine(horizonData) {
        if (!horizonData || horizonData.length === 0) return null;

        const polylinePoints = [];
        horizonData.forEach(point => {
            if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                polylinePoints.push([point.horizonLat, point.horizonLon]);
            } else {
                console.warn(`Skipping point (Azimuth: ${point.azimuth}) due to invalid horizonLat/Lon values. This point will not be part of the drawn viewshed polyline.`);
            }
        });

        if (polylinePoints.length >= 2) {
            // Close the polyline by adding the first point again at the end, if not already closed
            const firstPoint = polylinePoints[0];
            const lastPoint = polylinePoints[polylinePoints.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                polylinePoints.push(firstPoint);
            }
            console.log(`Viewshed terrain horizon polyline created with ${polylinePoints.length} points.`);
            return L.polyline(polylinePoints, {
                color: '#4299e1', // Blue color for the viewshed horizon line
                weight: 2,
                opacity: 0.7,
                smoothFactor: 1
            });
        } else {
            console.warn("Not enough valid geographical horizon points to draw a polyline.");
            return null;
        }
    }

    /**
     * Draws an individual circle marker on the map for a calculated point.
     * @param {object} point - Object with lat, lon, azimuth properties.
     * @param {string} label - Label for the popup.
     * @param {string} color - The color for the marker (e.g., 'red', 'blue', 'orange').
     * @param {number} [radius=6] - Radius of the marker.
     * @param {number} [fillOpacity=0.0] - Fill opacity of the marker (default to 0 for outline only).
     * @returns {L.CircleMarker|null} The created Leaflet CircleMarker object, or null if invalid point data.
     */
    function drawIndividualPointMarker(point, label, color = 'orange', radius = 6, fillOpacity = 0.0) {
        if (!map || !point || isNaN(point.lat) || isNaN(point.lon) || isNaN(point.azimuth)) {
            return null;
        }

        const marker = L.circleMarker([point.lat, point.lon], {
            radius: radius,
            fillColor: color, // Use provided color
            color: color, // Use provided color for outline
            weight: 2,
            opacity: 1,
            fillOpacity: fillOpacity // Use provided fill opacity
        });
        marker.bindPopup(`<b>${label}</b><br>Azimuth: ${point.azimuth.toFixed(3)}°<br>Lat: ${point.lat.toFixed(6)}<br>Lon: ${point.lon.toFixed(6)}`);
        console.log(`Marker for ${label} created (not yet added to map directly).`);
        return marker;
    }

    /**
     * Converts degrees to radians.
     * @param {number} deg - Degrees.
     * @returns {number} Radians.
     */
    function toRadians(deg) {
        return deg * Math.PI / 180;
    }

    /**
     * Converts radians to degrees.
     * @param {number} rad - Radians.
     * @returns {number} Degrees.
     */
    function toDegrees(rad) {
        return rad * 180 / Math.PI;
    }

    /**
     * Calculates the bearing from one LatLng point to another using LatLon library.
     * @param {L.LatLng} p1 - Start point.
     * @param {L.LatLng} p2 - End point.
     * @returns {number} Bearing in degrees.
     */
    function getBearingBetweenLatLngs(p1, p2) {
        if (typeof LatLon === 'undefined') {
            console.error("LatLon library not available for bearing calculation.");
            return NaN;
        }
        const ll1 = LatLon(p1.lat, p1.lng);
        const ll2 = LatLon(p2.lat, p2.lng);
        return ll1.bearingTo(ll2);
    }

    /**
     * Prepares Leaflet LatLngs for Turf.js by converting to [lng, lat] format.
     * This function performs NO filtering, as per user's strict instruction.
     * Also logs the resulting array to the console.
     * @param {Array<L.LatLng>} leafletLatLngs - Array of Leaflet LatLng objects.
     * @param {string} label - A label for console output (e.g., "Orthodrome", "Viewshed").
     * @returns {Array<Array<number>>} An array of [longitude, latitude] pairs, suitable for Turf.js.
     */
    function getTurfCoordinates(leafletLatLngs, label) {
        const turfCoords = [];
        // Assuming leafletLatLngs is an array of LatLng objects, potentially nested.
        // Access the inner array if present, otherwise assume it's flat.
        const actualLatLngs = (leafletLatLngs.length === 1 && Array.isArray(leafletLatLngs[0]) && typeof leafletLatLngs[0][0] === 'object' && 'lat' in leafletLatLngs[0][0]) ? leafletLatLngs[0] : leafletLatLngs;

        for (let i = 0; i < actualLatLngs.length; i++) {
            const ll = actualLatLngs[i];
            // Directly grab lat and lng. If they are undefined, they will remain undefined.
            const lng = ll ? ll.lng : undefined;
            const lat = ll ? ll.lat : undefined;
            turfCoords.push([lng, lat]);
        }
        console.log(`${label} coordinates passed to Turf.js (direct access, no filtering):`, turfCoords);
        return turfCoords;
    }

    /**
     * Rewritten function: Reformats raw Leaflet LatLng objects (potentially nested array of objects)
     * into an array of [longitude, latitude] pairs for Turf.js.
     * This function performs NO filtering, as per user's strict instruction, and uses direct property access.
     * It logs the reformatted array to the console.
     * @param {Array<any>} rawDataArray - The raw data array, expected to contain LatLng objects, potentially nested.
     * @param {string} label - A label for console output.
     * @returns {Array<Array<number>>} The reformatted array of [longitude, latitude] pairs.
     */
    function reformatAndLogRawLatLngsForTurf(rawDataArray, label) {
        const reformattedCoords = [];
        
        // Correctly access the inner array of LatLng objects if it's nested
        const actualLatLngObjects = (rawDataArray.length === 1 && Array.isArray(rawDataArray[0]) && typeof rawDataArray[0][0] === 'object' && 'lat' in rawDataArray[0][0]) ? rawDataArray[0] : rawDataArray;

        console.log(`reformatAndLogRawLatLngsForTurf received actual LatLng objects length: ${actualLatLngObjects.length}`);
        
        for (let i = 0; i < actualLatLngObjects.length; i++) {
            const ll = actualLatLngObjects[i]; // This is an individual LatLng object
            
            // Directly grab lat and lng properties. If ll is null/undefined or its properties are,
            // they will remain undefined, as per "no filtering".
            const lng = ll ? ll.lng : undefined;
            const lat = ll ? ll.lat : undefined;

            reformattedCoords.push([lng, lat]);
            console.log(`    Generated pair for index ${i}: [${lng}, ${lat}]`);
        }
        console.log(`Reformatted RAW ${label} LatLngs for Turf.js (direct access, no filtering):`, reformattedCoords);
        return reformattedCoords;
    }

    /**
     * Normalizes an azimuth to be within the 0-360 degree range.
     * Exposed globally to resolve potential ReferenceError.
     * @param {number} az - Azimuth in degrees.
     * @returns {number} Normalized azimuth in degrees (0-360).
     */
    window.normalizeAzimuth = function(az) {
        return (az % 360 + 360) % 360;
    };


    /**
     * Calculates the Sun's celestial altitude and azimuth for a given observer location, declination, and hour angle.
     * Formulas based on spherical astronomy.
     * @param {number} observerLatDeg - Observer's Latitude in Degrees.
     * @param {number} declinationDeg - Sun's Declination in Degrees.
     * @param {number} hourAngleDeg - Hour Angle in Degrees (0 at local meridian, increases westward).
     * @returns {{altitude: number, azimuth: number}|null} Object with altitude and azimuth in degrees, or null if invalid input.
     */
    function calculateSunPosition(observerLatDeg, declinationDeg, hourAngleDeg) {
        if (isNaN(observerLatDeg) || isNaN(declinationDeg) || isNaN(hourAngleDeg)) {
            console.error("Invalid input to calculateSunPosition: NaN detected.");
            return null;
        }

        const latRad = toRadians(observerLatDeg);
        const decRad = toRadians(declinationDeg);
        const haRad = toRadians(hourAngleDeg);

        // Calculate Altitude (h)
        // sin(h) = sin(dec)sin(lat) + cos(dec)cos(lat)cos(HA)
        const sinAltitude = Math.sin(decRad) * Math.sin(latRad) +
                            Math.cos(decRad) * Math.cos(latRad) * Math.cos(haRad);
        let altitudeRad = Math.asin(sinAltitude); // Altitude in radians

        // Calculate Azimuth (A)
        // cos(A) = (sin(dec) - sin(h)sin(lat)) / (cos(h)cos(lat))
        // Use atan2 for correct quadrant
        const sinAz = -Math.sin(haRad) * Math.cos(decRad);
        const cosAz = Math.sin(decRad) * Math.cos(latRad) - Math.cos(decRad) * Math.sin(latRad) * Math.cos(haRad);
        let azimuthRad = Math.atan2(sinAz, cosAz);
        azimuthRad = (azimuthRad + 2 * Math.PI) % (2 * Math.PI); // Normalize to 0 to 2PI (from North, clockwise)

        return {
            altitude: toDegrees(altitudeRad),
            azimuth: toDegrees(azimuthRad)
        };
    }


    /**
     * Finds the true rise/set azimuth by locating the point on the viewshed horizon
     * whose apparent altitude matches the celestial body's target apparent altitude.
     * This now uses dynamic sun position calculations.
     * Exposed globally to resolve potential ReferenceError.
     * @param {Array<Object>} horizonData - An array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @param {string} targetLimb - 'UL', 'Center', or 'LL' to specify which part of the Sun.
     * @param {number} initialAzimuthGuess - The scenario-specific initial 0-horizon azimuth guess (e.g., from Turf.js intersection).
     * @param {string} scenarioName - A descriptive name for the current calculation scenario (e.g., "Upper Limb").
     * @param {number} observerLat - The observer's latitude.
     * @param {number} observerLon - The observer's longitude.
     * @param {boolean} isSunriseLike - True if it's a sunrise-like event (azimuth increasing), false for sunset-like (azimuth decreasing).
     * @param {number} declinationDeg - The Sun's declination in degrees.
     * @returns {{azimuth: number|null, lat: number|null, lon: number: number|null, hourAngle: number}|null} The calculated azimuth, Lat/Lon, and hour angle, or null if no matching point found.
     */
    window.findActualAzimuthForTargetApparentAltitude = async function( // Exposed globally
        horizonData,
        targetLimb, // 'UL', 'Center', 'LL'
        initialAzimuthGuess,
        scenarioName,
        observerLat,
        observerLon,
        isSunriseLike,
        declinationDeg // New: Declination in degrees
    ) {
        const TOLERANCE_ALTITUDE = 0.001; // degrees, for matching altitude
        const TIME_STEP_MINUTES = 0.5; // minutes, for iterative time search (e.g., 30 seconds)
        const HOUR_ANGLE_STEP_DEG = TIME_STEP_MINUTES * (360 / (24 * 60)); // Convert minutes to degrees of Hour Angle
        const SEARCH_RANGE_HOURS = 2; // Hours around initial guess to search for event

        function setScenarioStatus(message, type = 'status') {
            console.log(`Display Message [${type}]: ${message}`);
        }
        setScenarioStatus(`Calculating ${scenarioName}...`, 'status');

        if (isNaN(initialAzimuthGuess) || isNaN(declinationDeg)) {
            console.error(`ERROR: Invalid input for ${scenarioName}: initialAzimuthGuess or declination is NaN.`);
            setScenarioStatus(`${scenarioName}: Error: Invalid input.`, 'error');
            return null;
        }

        let minHorizonAlt = Infinity;
        let maxHorizonAlt = -Infinity;
        if (horizonData.length > 0) {
            for (const point of horizonData) {
                if (point.altitude < minHorizonAlt) minHorizonAlt = point.altitude;
                if (point.altitude > maxHorizonAlt) maxHorizonAlt = point.altitude;
            }
        } else {
            console.error(`findActualAzimuthForTargetApparentAltitude (${scenarioName}): Empty horizonData received.`);
            setScenarioStatus(`${scenarioName}: Error: Empty horizon data.`, 'error');
            return null;
        }

        // --- Determine initial hour angle for search based on initialAzimuthGuess ---
        // This is a more robust way to get an initial hour angle for the search.
        // We iterate through a range of hour angles to find the one that produces an azimuth closest to initialAzimuthGuess.
        let bestInitialHAAzimuthDiff = Infinity;
        let bestInitialHA = 0;
        const HA_SEARCH_RESOLUTION = 0.5; // degrees, for initial HA search
        const HA_SEARCH_RANGE = 180; // degrees, search +/- this range around 0HA

        for (let ha = -HA_SEARCH_RANGE; ha <= HA_SEARCH_RANGE; ha += HA_SEARCH_RESOLUTION) {
            const sunPosAtHA = calculateSunPosition(observerLat, declinationDeg, ha);
            if (sunPosAtHA) {
                const diff = Math.abs(window.normalizeAzimuth(sunPosAtHA.azimuth) - window.normalizeAzimuth(initialAzimuthGuess));
                if (diff < bestInitialHAAzimuthDiff) {
                    bestInitialHAAzimuthDiff = diff;
                    bestInitialHA = ha;
                }
            }
        }
        let estimatedInitialHourAngleDeg = bestInitialHA;
        console.log(`${scenarioName}: Estimated initial Hour Angle for search: ${estimatedInitialHourAngleDeg.toFixed(3)}° (closest azimuth match to guess).`);


        let bestMatch = null;
        let foundCrossing = false;

        // Iterate over a range of hour angles (e.g., +/- SEARCH_RANGE_HOURS around the estimated initial HA)
        const totalSteps = (SEARCH_RANGE_HOURS * 2 * 60) / TIME_STEP_MINUTES;
        const startHourAngle = estimatedInitialHourAngleDeg - (SEARCH_RANGE_HOURS * (360 / 24)); // Start X hours before estimated
        const endHourAngle = estimatedInitialHourAngleDeg + (SEARCH_RANGE_HOURS * (360 / 24)); // End X hours after estimated

        let prevSunAltLimb = null;
        let prevTerrainAlt = null;
        let prevHourAngle = null;

        for (let i = 0; i <= totalSteps; i++) {
            const currentHourAngle = startHourAngle + (i * HOUR_ANGLE_STEP_DEG);
            const sunPos = calculateSunPosition(observerLat, declinationDeg, currentHourAngle);

            if (!sunPos) continue; // Skip if sun position calculation failed

            let sunAltitudeLimb = sunPos.altitude;
            if (targetLimb === 'UL') {
                sunAltitudeLimb -= SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                sunAltitudeLimb += SOLAR_SEMIDIAMETER;
            }
            // Note: Atmospheric refraction is assumed to be handled by the "apparent" nature of HWT altitudes.

            const terrainAltitude = getInterpolatedHorizonAltitude(sunPos.azimuth, horizonData);

            if (terrainAltitude === null) {
                console.warn(`${scenarioName}: Could not interpolate terrain altitude at azimuth ${sunPos.azimuth.toFixed(3)}°. Skipping.`);
                prevSunAltLimb = sunAltitudeLimb;
                prevTerrainAlt = null; // Reset prevTerrainAlt if interpolation fails
                prevHourAngle = currentHourAngle;
                continue;
            }

            const isSunAboveTerrain = sunAltitudeLimb > terrainAltitude;

            if (prevSunAltLimb !== null && prevTerrainAlt !== null && prevHourAngle !== null) {
                const wasSunAboveTerrain = prevSunAltLimb > prevTerrainAlt;

                // Check for crossing: Sun's limb altitude relative to terrain altitude
                // For rise: Sun's limb goes from below terrain to above terrain
                // For set: Sun's limb goes from above terrain to below terrain
                const hasCrossed = (isSunriseLike && !wasSunAboveTerrain && isSunAboveTerrain) ||
                                   (!isSunriseLike && wasSunAboveTerrain && !isSunAboveTerrain);

                if (hasCrossed) {
                    foundCrossing = true;
                    // Perform a finer search within this segment [prevHourAngle, currentHourAngle]
                    let lowHA = prevHourAngle;
                    let highHA = currentHourAngle;
                    let fineSearchIterations = 0;
                    const MAX_FINE_SEARCH_ITERATIONS = 50; // Prevent infinite loops

                    let finalHA = null;

                    while (fineSearchIterations < MAX_FINE_SEARCH_ITERATIONS) {
                        const midHA = (lowHA + highHA) / 2;
                        const midSunPos = calculateSunPosition(observerLat, declinationDeg, midHA);
                        if (!midSunPos) break;

                        let midSunAltLimb = midSunPos.altitude;
                        if (targetLimb === 'UL') {
                            midSunAltLimb -= SOLAR_SEMIDIAMETER;
                        } else if (targetLimb === 'LL') {
                            midSunAltLimb += SOLAR_SEMIDIAMETER;
                        }

                        const midTerrainAlt = getInterpolatedHorizonAltitude(midSunPos.azimuth, horizonData);
                        if (midTerrainAlt === null) {
                            console.warn(`${scenarioName}: Fine search failed to interpolate terrain at ${midSunPos.azimuth.toFixed(3)}°. Breaking fine search.`);
                            break;
                        }

                        const currentDifference = midSunAltLimb - midTerrainAlt;

                        if (Math.abs(currentDifference) < TOLERANCE_ALTITUDE) {
                            finalHA = midHA;
                            break;
                        }

                        // Adjust search range based on whether Sun is above or below terrain
                        if (isSunriseLike) { // For rise, we want Sun to go from below to above terrain
                            if (currentDifference < 0) { // Sun is still below terrain
                                lowHA = midHA;
                            } else { // Sun is above terrain
                                highHA = midHA;
                            }
                        } else { // For set, we want Sun to go from above to below terrain
                            if (currentDifference > 0) { // Sun is still above terrain
                                lowHA = midHA;
                            } else { // Sun is below terrain
                                highHA = midHA;
                            }
                        }
                        fineSearchIterations++;
                    }

                    if (finalHA !== null) {
                        const finalSunPos = calculateSunPosition(observerLat, declinationDeg, finalHA);
                        if (finalSunPos) {
                            const finalPointLatLon = getInterpolatedHorizonLatLon(finalSunPos.azimuth, horizonData);
                            if (finalPointLatLon) {
                                setScenarioStatus(`${scenarioName}: Actual Azimuth calculated.`, 'success');
                                return {
                                    azimuth: finalSunPos.azimuth,
                                    lat: finalPointLatLon.lat,
                                    lon: finalPointLatLon.lon,
                                    hourAngle: finalHA
                                };
                            }
                        }
                    }
                }
            }

            prevSunAltLimb = sunAltitudeLimb;
            prevTerrainAlt = terrainAltitude;
            prevHourAngle = currentHourAngle;
        }

        // If no crossing found within the search range, check if always clear or always blocked
        // This part needs careful consideration if the initial search range is too small or initial guess is way off.
        const initialSunPosAtGuessAzimuth = calculateSunPosition(observerLat, declinationDeg, estimatedInitialHourAngleDeg);
        if (initialSunPosAtGuessAzimuth) {
            let initialSunAltLimb = initialSunPosAtGuessAzimuth.altitude;
            if (targetLimb === 'UL') {
                initialSunAltLimb -= SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                initialSunAltLimb += SOLAR_SEMIDIAMETER;
            }
            const initialTerrainAlt = getInterpolatedHorizonAltitude(initialSunPosAtGuessAzimuth.azimuth, horizonData);

            if (initialTerrainAlt !== null) {
                if (initialSunAltLimb < initialTerrainAlt - TOLERANCE_ALTITUDE) {
                    setScenarioStatus(`${scenarioName}: Object appears to be always clear of terrain in this azimuth range.`, 'warn');
                    // Return the position at the initial guess azimuth if it's consistently clear
                    const dummyPoint = getInterpolatedHorizonLatLon(initialSunPosAtGuessAzimuth.azimuth, horizonData);
                    return { azimuth: initialSunPosAtGuessAzimuth.azimuth, lat: dummyPoint?.lat, lon: dummyPoint?.lon, hourAngle: estimatedInitialHourAngleDeg };
                } else if (initialSunAltLimb > initialTerrainAlt + TOLERANCE_ALTITUDE) {
                    setScenarioStatus(`${scenarioName}: Object appears to be always blocked by terrain in this azimuth range.`, 'error');
                    return null;
                }
            }
        }


        console.error(`Critical (${scenarioName}): No valid intersection azimuth found after iterative search.`);
        setScenarioStatus(`${scenarioName}: Critical error. No match found.`, 'error');
        return null;
    };


    /**
     * Finds the intersection point on the viewshed horizon for a given orthodromic line using Turf.js.
     * @param {L.LatLng} observerLatLng - The observer's location.
     * @param {Array<Array<number>>} orthodromeCoordsTurf - Array of [longitude, latitude] for the orthodromic line.
     * @param {Array<Array<number>>} viewshedCoordsTurf - Array of [longitude, latitude] for the viewshed horizon.
     * @returns {{lat: number, lon: number, azimuth: number}|null} The intersection point, or null if not found.
     */
    function findOrthodromeViewshedIntersection(observerLatLng, orthodromeCoordsTurf, viewshedCoordsTurf) {
        if (typeof turf === 'undefined') {
            console.error("Turf.js library not loaded. Cannot perform line intersection.");
            return null;
        }

        // --- Filter out invalid coordinates before passing to turf.lineString ---
        const validOrthodromeCoords = orthodromeCoordsTurf.filter(coords => 
            typeof coords[0] === 'number' && !isNaN(coords[0]) &&
            typeof coords[1] === 'number' && !isNaN(coords[1])
        );
        const validViewshedCoords = viewshedCoordsTurf.filter(coords => 
            typeof coords[0] === 'number' && !isNaN(coords[0]) &&
            typeof coords[1] === 'number' && !isNaN(coords[1])
        );

        console.log("Orthodrome coordinates provided to turf.lineString (filtered for validity):", validOrthodromeCoords);
        console.log("Viewshed coordinates provided to turf.lineString (filtered for validity):", validViewshedCoords);
        // --- END NEW ---

        // Check if there are enough valid coordinates after filtering
        if (validOrthodromeCoords.length < 2 || validViewshedCoords.length < 2) {
            console.warn("Insufficient valid coordinates after filtering for Turf.js intersection. Skipping intersection.");
            return null;
        }

        // The coordinates are now guaranteed to be valid numbers for turf.lineString
        const turfOrthodrome = turf.lineString(validOrthodromeCoords);
        const turfViewshed = turf.lineString(validViewshedCoords);

        // Find intersections
        const intersections = turf.lineIntersect(turfOrthodrome, turfViewshed);

        if (intersections.features.length > 0) {
            // Pick the first intersection point (closest to the start of the orthodrome)
            const intersectionCoords = intersections.features[0].geometry.coordinates;
            
            // Per user instruction, no explicit validation or parseFloat here.
            const intersectionLat = intersectionCoords[1];
            const intersectionLon = intersectionCoords[0];

            const intersectionLatLng = L.latLng(intersectionLat, intersectionLon);

            const actualIntersectionAzimuth = getBearingBetweenLatLngs(observerLatLng, intersectionLatLng);
            
            console.log("Turf.js Intersection found at Lat: " + intersectionLat.toFixed(6) + ", Lon: " + intersectionLon.toFixed(6) + ", Azimuth: " + actualIntersectionAzimuth.toFixed(3) + "°");
            return {
                lat: intersectionLat,
                lon: intersectionLon,
                azimuth: actualIntersectionAzimuth
            };
        }

        return null; // No intersection found
    }


    /**
     * Fetches location data (lat, lon, elev_amsl) for a specific ID from heywhatsthat.com's result.json.
     * (Retained for observer location data)
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<{latitude: number, longitude: number, elevation_amsl: number}|null>} Parsed location info.
     */
    async function fetchLocationData(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/bin/result.json?id=${hwtId}`;

        window.displayMessage('locationStatus', `Fetching location data for ID: ${hwtId} from /bin/result.json...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const json = JSON.parse(text);

            const lat = parseFloat(json?.lat);
            const lon = parseFloat(json?.lon);
            const elev_amsl = parseFloat(json?.elev_amsl);

            if (!isNaN(lat) && !isNaN(lon) && !isNaN(elev_amsl)) {
                window.displayMessage('locationStatus', 'Location data fetched successfully.', 'success-message');
                return { latitude: lat, longitude: lon, elevation_amsl: elev_amsl };
            }
            throw new Error("Missing or invalid 'lat', 'lon', or 'elev_amsl' in JSON response.");

        } catch (error) {
            window.displayMessage('locationStatus', 'Error fetching location data.', 'error-message');
            window.displayMessage('locationError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching location data:", error);
            return null;
        }
    }

    /**
     * Fetches and parses viewshed data from heywhatsthat.com's horizon.csv API.
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<Array<Object>>} A promise resolving to an array of {azimuth, altitude, horizonLat?, horizonLon?} objects.
     */
    async function fetchHorizonDataHoriZONE(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/api/horizon.csv?id=${hwtId}&resolution=.125&src=${HWT_HORIZONE_SRC}&keep=1`;

        window.displayMessage('viewshedStatus', `Fetching viewshed data for ID: ${hwtId} from /api/horizon.csv (horiZONE method)...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const lines = text.trim().split('\n');
            const horizonData = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#') || line === '') continue;

                const parts = line.split(',').map(s => s.trim());
                // Expecting at least Azimuth (0), Altitude (1), Distance (2), Slope (3), Latitude (4), Longitude (5) - 6 columns
                if (parts.length >= 6) {
                    const azimuth = parseFloat(parts[0]);
                    const altitude = parseFloat(parts[1]);
                    const horizonLat = parseFloat(parts[4]); // 5th column (index 4)
                    const horizonLon = parseFloat(parts[5]); // 6th column (index 5)

                    if (!isNaN(azimuth) && !isNaN(altitude) && !isNaN(horizonLat) && !isNaN(horizonLon)) {
                        horizonData.push({ azimuth, altitude, horizonLat, horizonLon });
                    } else {
                        console.warn(`Skipping line ${i} due to invalid number parsing (az:${parts[0]}, alt:${parts[1]}, lat:${parts[4]}, lon:${parts[5]}): ${line}`);
                    }
                } else {
                    console.warn(`Skipping line ${i} due to insufficient columns (${parts.length} < 6): ${line}`);
                }
            }

            if (horizonData.length === 0) {
                throw new Error("No valid azimuth-altitude-lat-lon pairs parsed from horizon.csv. Response might be malformed or empty data.");
            }

            horizonData.sort((a, b) => a.azimuth - b.azimuth);
            window.displayMessage('viewshedStatus', 'Viewshed data fetched successfully.', 'success-message');
            return horizonData;

        } catch (error) {
            window.displayMessage('viewshedStatus', 'Error fetching viewshed data.', 'error-message');
            window.displayMessage('viewshedError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching viewshed data:", error);
            return null;
        }
    }

    // Helper function to create and add a polygon layer group
    async function createAndAddPolygonLayer(
        initialAzimuthUL, initialAzimuthCenter, initialAzimuthLL,
        horizonData, locationData, polygonColor, scenarioName, layerGroupName,
        isSunriseLike, declinationDeg // New: isSunriseLike and declinationDeg
    ) {
        const observerLatLng = [locationData.latitude, locationData.longitude];
        
        // The initialAzimuthUL, initialAzimuthCenter, initialAzimuthLL are now used as initial guess for the time-based search
        const actualPointUL = await window.findActualAzimuthForTargetApparentAltitude(
            horizonData, 'UL', initialAzimuthUL, `${scenarioName} Upper Limb at Horizon`, locationData.latitude, locationData.longitude, isSunriseLike, declinationDeg
        );
        const actualPointCenter = await window.findActualAzimuthForTargetApparentAltitude(
            horizonData, 'Center', initialAzimuthCenter, `${scenarioName} Center at Horizon`, locationData.latitude, locationData.longitude, isSunriseLike, declinationDeg
        );
        const actualPointLL = await window.findActualAzimuthForTargetApparentAltitude(
            horizonData, 'LL', initialAzimuthLL, `${scenarioName} Lower Limb at Horizon`, locationData.latitude, locationData.longitude, isSunriseLike, declinationDeg
        );

        let layerGroup = L.layerGroup();
        layerGroup.layerNameForControl = layerGroupName; // Store name for layers control

        let anyPointMissing = !(actualPointUL && actualPointCenter && actualPointLL);
        if (anyPointMissing) {
            console.warn(`Cannot draw ${scenarioName} polygon: one or more critical points are missing.`);
            return { layerGroup: layerGroup, success: false };
        }

        const polygonLatLngs = [];
        polygonLatLngs.push(observerLatLng);

        // Add UL point
        polygonLatLngs.push([actualPointUL.lat, actualPointUL.lon]);
        console.log(`Adding ${scenarioName} UL point to polygon: ${actualPointUL.lat.toFixed(6)}, ${actualPointUL.lon.toFixed(6)}`);

        // Add intermediate points between UL and Center
        let pointsBetweenULCenter;
        if (isSunriseLike) {
            pointsBetweenULCenter = getIntermediateHorizonPoints(actualPointUL.azimuth, actualPointCenter.azimuth, horizonData);
            pointsBetweenULCenter.forEach(p => { console.log(`Adding intermediate point (${scenarioName} UL-Center): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); });
        } else { // Sunset-like, traverse counter-clockwise for intermediate points
            pointsBetweenULCenter = getIntermediateHorizonPoints(actualPointCenter.azimuth, actualPointUL.azimuth, horizonData);
            pointsBetweenULCenter.reverse().forEach(p => { console.log(`Adding intermediate point (${scenarioName} UL-Center, reversed): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); });
        }
        pointsBetweenULCenter.forEach(p => polygonLatLngs.push(p)); // Add points to polygon

        // Add Center point
        polygonLatLngs.push([actualPointCenter.lat, actualPointCenter.lon]);
        console.log(`Adding ${scenarioName} Center point to polygon: ${actualPointCenter.lat.toFixed(6)}, ${actualPointCenter.lon.toFixed(6)}`);

        // Add intermediate points between Center and LL
        let pointsBetweenCenterLL;
        if (isSunriseLike) {
            pointsBetweenCenterLL = getIntermediateHorizonPoints(actualPointCenter.azimuth, actualPointLL.azimuth, horizonData);
            pointsBetweenCenterLL.forEach(p => { console.log(`Adding intermediate point (${scenarioName} Center-LL): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); });
        } else { // Sunset-like, traverse counter-clockwise for intermediate points
            pointsBetweenCenterLL = getIntermediateHorizonPoints(actualPointLL.azimuth, actualPointCenter.azimuth, horizonData);
            pointsBetweenCenterLL.reverse().forEach(p => { console.log(`Adding intermediate point (${scenarioName} Center-LL, reversed): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); });
        }
        pointsBetweenCenterLL.forEach(p => polygonLatLngs.push(p)); // Add points to polygon

        // Add LL point
        polygonLatLngs.push([actualPointLL.lat, actualPointLL.lon]);
        console.log(`Adding ${scenarioName} LL point to polygon: ${actualPointLL.lat.toFixed(6)}, ${actualPointLL.lon.toFixed(6)}`);

        polygonLatLngs.push(observerLatLng); // Close the polygon

        const polygon = L.polygon(polygonLatLngs, {
            color: polygonColor,
            weight: 2,
            opacity: 1,
            dashArray: '5, 10',
            fillColor: polygonColor,
            fillOpacity: 0.1
        });
        layerGroup.addLayer(polygon);

        // Add individual markers to the layer group
        layerGroup.addLayer(drawIndividualPointMarker(actualPointUL, `${scenarioName} Upper Limb`, polygonColor));
        layerGroup.addLayer(drawIndividualPointMarker(actualPointCenter, `${scenarioName} Center`, polygonColor));
        layerGroup.addLayer(drawIndividualPointMarker(actualPointLL, `${scenarioName} Lower Limb`, polygonColor));

        // Add the layer group to the map and layers control
        window.map.addLayer(layerGroup);
        window.layersControl.addOverlay(layerGroup, layerGroupName);
        window.scriptCOverlayGroups.push(layerGroup); // Add to Script C's managed layers

        return { layerGroup: layerGroup, success: true };
    }


    // --- Event Listener for Form Submission ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Assign global map and layersControl from Script B once DOM is ready
        map = window.map;
        layersControl = window.layersControl;
        observerMarker = window.bigMarker; // Script B's draggable marker

        const form = document.getElementById('azimuthForm');
        const hwtIdentifierInput = document.getElementById('hwtIdentifierInput');
        const loadingSpinner = document.getElementById('loadingSpinner');

        form.addEventListener('submit', async (e) => {
            e.preventDefault(); // Prevent default form submission behavior (page reload)

            window.clearResultsDisplay(); // Use global clearResultsDisplay
            window.displayMessage('overallStatus', 'Starting terrain-adjusted azimuth calculation...', 'status');
            if (loadingSpinner) loadingSpinner.classList.remove('hidden');

            const hwtId = hwtIdentifierInput.value.trim();

            if (!hwtId) {
                window.displayMessage('overallStatus', 'Error: Please enter a HeyWhatsThat Identifier.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return; // Exit early if hwtId is empty
            }

            let locationData = null;
            let horizonData = null;
            let anyCalculationFailed = false;

            // --- Fetch Location Data ---
            locationData = await fetchLocationData(hwtId);
            if (!locationData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch location data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // Update Script B's map and marker with fetched location data
            // This is for visual consistency, not for calculation input in Script C.
            if (map && observerMarker) {
                map.setView([locationData.latitude, locationData.longitude], map.getZoom());
                observerMarker.setLatLng([locationData.latitude, locationData.longitude]);
                document.getElementById('latbox').value = locationData.latitude;
                document.getElementById('lngbox').value = locationData.longitude;
                observerMarker.bindPopup(`<b>Observer Location</b><br>Lat: ${locationData.latitude.toFixed(4)}, Lon: ${locationData.longitude.toFixed(4)}`).openPopup();
            } else {
                console.error("Leaflet map or observer marker not available from Script B.");
                window.displayMessage('overallStatus', 'Error: Map components not ready.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- Fetch Viewshed Data ---
            horizonData = await fetchHorizonDataHoriZONE(hwtId);
            if (!horizonData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch viewshed data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            window.displayMessage('overallStatus', "Calculating actual azimuths...", 'status');

            // --- Viewshed Horizon Line ---
            const viewshedPolyline = drawViewshedHorizonLine(horizonData);
            if (viewshedPolyline) {
                let viewshedHorizonLineGroup = L.layerGroup();
                viewshedHorizonLineGroup.addLayer(viewshedPolyline);
                viewshedHorizonLineGroup.layerNameForControl = "Viewshed Horizon"; // Name for layers control
                window.map.addLayer(viewshedHorizonLineGroup);
                window.layersControl.addOverlay(viewshedHorizonLineGroup, viewshedHorizonLineGroup.layerNameForControl);
                window.scriptCOverlayGroups.push(viewshedHorizonLineGroup);
            }

            // --- Read Mapped Azimuth Values from Script A's Global Variables ---
            // These values are now correctly read directly from the global JavaScript variables
            // that Script A populates. NO .value or parseFloat needed here.
            let wsrZeroHorizonAzimuth = window.solsticeaziwinrise;
            let wssZeroHorizonAzimuth = window.solsticeaziwinset;
            let ssrZeroHorizonAzimuth = window.solsticeazisumrise;
            let sssZeroHorizonAzimuth = window.solsticeazisumset;
            let ncqrZeroHorizonAzimuth = window.crossquarterazisumrise;
            let scqrZeroHorizonAzimuth = window.crossquarteraziwinrise;
            let ncqsZeroHorizonAzimuth = window.crossquarterazisumset;
            let scqsZeroHorizonAzimuth = window.crossquarteraziwinset;
            let nmlrZeroHorizonAzimuth = window.majorazisumrise;
            let nmlsZeroHorizonAzimuth = window.majorazisumset;
            let smlrZeroHorizonAzimuth = window.majoraziwinrise;
            let smnlsZeroHorizonAzimuth_major = window.majoraziwinset; // Renamed to avoid collision
            let nmnlrZeroHorizonAzimuth = window.minorazisumrise;
            let smnlrZeroHorizonAzimuth = window.minoraziwinrise;
            let nmnlsZeroHorizonAzimuth = window.minorazisumset;
            let smnlsZeroHorizonAzimuth_minor = window.minoraziwinset; // Renamed to avoid collision
            let erZeroHorizonAzimuth = window.equinoxazisumrise;
            let esZeroHorizonAzimuth = window.equinoxazisumset;
            // --- END MAPPED AZIMUTH VALUES ---

            // --- Get Declination Value from window.declination (provided by Script A) ---
            // For Summer Solstice Rise, we specifically need window.declinationSummerSolstice
            const declinationDeg = window.declinationSummerSolstice; // Correctly pull from Script A's specific variable

            // --- NEW: Log the value of declinationDeg immediately after accessing ---
            console.log(`Value of declinationDeg just before isNaN check: ${declinationDeg}`);

            if (isNaN(declinationDeg)) {
                console.error("ERROR: Declination value (window.declinationSummerSolstice) is not a valid number. Please ensure Script A correctly sets window.declinationSummerSolstice.");
                window.displayMessage('overallStatus', 'Error: Declination data missing or invalid. Check Script A.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }
            console.log(`Declination used: ${declinationDeg}°`);


            // --- Orthodrome Data Processing and Intersection ---
            let baseAzimuthSSRForOrthodrome = ssrZeroHorizonAzimuth; // Use the correct SSR azimuth from global
            console.log("Initial 0-horizon azimuth used for Orthodrome:", baseAzimuthSSRForOrthodrome);

            let orthodromeLatLngsForGeodesic = [];
            let rawGeodesicLatLngs = [];
            let intersectionPoint = null; // Declare intersectionPoint here

            if (!isNaN(baseAzimuthSSRForOrthodrome) && locationData && typeof LatLon !== 'undefined' && typeof L.geodesic !== 'undefined') {
                const observerLat = locationData.latitude;
                const observerLon = locationData.longitude;
                const lineDistanceKm = 200; // Sufficient distance to cross most horizons

                const startPointLatLon = LatLon(observerLat, observerLon);
                const endPointLatLon = startPointLatLon.destinationPoint(lineDistanceKm * 1000, baseAzimuthSSRForOrthodrome);

                if (isNaN(endPointLatLon.lat) || isNaN(endPointLatLon.lon)) {
                    console.warn("Calculated orthodrome end point is invalid (NaN).");
                    window.displayMessage('overallStatus', 'Warning: Orthodrome end point calculation failed. Check azimuth input.', 'warn');
                    orthodromeLatLngsForGeodesic = [L.latLng(observerLat, observerLon), L.latLng(NaN, NaN)];
                } else {
                    orthodromeLatLngsForGeodesic = [
                        L.latLng(observerLat, observerLon),
                        L.latLng(endPointLatLon.lat, endPointLatLon.lon)
                    ];
                }

                // Attempt to create geodesic line to get intermediate points (even if endpoints might be NaN, for raw output)
                let tempOrthodromeLine = L.geodesic(orthodromeLatLngsForGeodesic, {
                    steps: 100 // Keep steps for raw data generation consistency
                });

                rawGeodesicLatLngs = tempOrthodromeLine.getLatLngs();
                console.log("Raw Geodesic Orthodrome Attempt LatLngs:", rawGeodesicLatLngs);

                // Process raw geodesic LatLngs to get Turf-compatible array (no filtering) and log it immediately
                const reformattedOrthodromeCoords = reformatAndLogRawLatLngsForTurf(rawGeodesicLatLngs, "Geodesic Orthodrome Attempt");

                // --- Find and Draw Intersection Point ---
                if (viewshedPolyline && locationData && typeof turf !== 'undefined') {
                    // Get raw LatLngs from the viewshed polyline and then format for Turf.
                    const viewshedActualLatLngs = viewshedPolyline.getLatLngs(); // This is already the L.polyline's LatLngs
                    const filteredViewshedCoordsTurf = getTurfCoordinates(viewshedActualLatLngs, "Viewshed Horizon");

                    const observerLatLng = L.latLng(locationData.latitude, locationData.longitude);

                    // Pass the already formatted arrays directly to the intersection function
                    intersectionPoint = findOrthodromeViewshedIntersection(observerLatLng, reformattedOrthodromeCoords, filteredViewshedCoordsTurf); // Assign to declared variable

                    if (intersectionPoint) {
                        // Draw the intersection point marker: half size (radius 3), orange, solid fill
                        ssrIntersectionMarker = drawIndividualPointMarker(intersectionPoint, "SSR Orthodrome Intersection", 'orange', 3, 1);
                        if (ssrIntersectionMarker) {
                            ssrIntersectionLayerGroup = L.layerGroup(); // Create a new layer group for the marker
                            ssrIntersectionLayerGroup.addLayer(ssrIntersectionMarker); // Add marker to its group
                            ssrIntersectionLayerGroup.layerNameForControl = "SSR Orthodrome Intersection"; // Name for layers control
                            
                            map.addLayer(ssrIntersectionLayerGroup); // Add the group to the map
                            layersControl.addOverlay(ssrIntersectionLayerGroup, ssrIntersectionLayerGroup.layerNameForControl); // Add group to layers control
                            window.scriptCOverlayGroups.push(ssrIntersectionLayerGroup); // Add the group to Script C's managed layers
                            console.log("Intersection marker layer group added to map.");
                        }
                    } else {
                        console.warn("No intersection found between SSR Orthodrome and Viewshed Horizon, or orthodrome/viewshed data invalid for intersection calculation.");
                        window.displayMessage('overallStatus', 'Warning: No orthodrome intersection found.', 'warn');
                    }
                } else {
                    console.warn("Cannot find intersection: Viewshed Horizon line not available, or location data missing, or Turf.js not loaded.");
                }
            } else {
                console.warn("Cannot process Orthodrome data: base azimuth or location data invalid, or LatLon/L.geodesic not available.");
                window.displayMessage('overallStatus', 'Warning: Orthodrome processing skipped due to missing libraries or invalid data.', 'warn');
            }

            // Determine the base azimuth for the polygon based on intersection or fallback
            let baseAzimuthForPolygon = ssrZeroHorizonAzimuth;
            if (intersectionPoint && !isNaN(intersectionPoint.azimuth)) {
                baseAzimuthForPolygon = intersectionPoint.azimuth;
                console.log(`Using Turf intersection azimuth (${baseAzimuthForPolygon.toFixed(3)}°) as base for SSR polygon.`);
            } else {
                console.log(`Using original 0-horizon azimuth (${ssrZeroHorizonAzimuth.toFixed(3)}°) as base for SSR polygon (no valid intersection).`);
            }


            // --- Process only Summer Solstice Rise (SSR) with updated initial guess and dynamic sun position ---
            // Pass isSunriseLike and declinationDeg to findActualAzimuthForTargetApparentAltitude
            const isSunriseLikeSSR = (parseFloat(baseAzimuthForPolygon) >= 0 && parseFloat(baseAzimuthForPolygon) <= 180);
            var ssrResult = await createAndAddPolygonLayer(
                baseAzimuthForPolygon, // Use the new base azimuth as initial guess for time-based search
                window.normalizeAzimuth(baseAzimuthForPolygon + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)), // These are now just conceptual guesses for the search
                window.normalizeAzimuth(baseAzimuthForPolygon + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)), // These are now just conceptual guesses for the search
                horizonData, locationData, POLYGON_COLORS[0], "SSR", "Summer Solstice Rise",
                isSunriseLikeSSR, declinationDeg // Pass new parameters
            );
            if (!ssrResult.success) anyCalculationFailed = true;


            // Adjust map bounds to encompass all drawn elements
            let bounds = new L.LatLngBounds();
            window.scriptCOverlayGroups.forEach(layerGroup => { // Use window.scriptCOverlayGroups
                if (window.map.hasLayer(layerGroup)) {
                    layerGroup.eachLayer(function(subLayer) {
                        if (subLayer.getLatLngs) { // For polygons/polylines
                            bounds.extend(subLayer.getBounds());
                        } else if (subLayer.getLatLng) { // For markers
                            bounds.extend(subLayer.getLatLng());
                        }
                    });
                }
            });

            // Also include the observer marker in the bounds
            if (observerMarker && observerMarker.getLatLng()) {
                bounds.extend(observerMarker.getLatLng());
            }

            if (bounds.isValid()) {
                window.map.fitBounds(bounds, { padding: [50, 50] });
            }

            if (!anyCalculationFailed) {
                window.displayMessage('overallStatus', 'Calculation Complete for all scenarios.', 'success');
            } else {
                window.displayMessage('overallStatus', 'Calculation finished with some scenarios not finding a direct match. Check detailed statuses and console for more info.', 'warn');
            }
            if (loadingSpinner) loadingSpinner.classList.add('hidden');
        });

        // --- GeoJSON Export Functionality (Removed from here, will be in separate script) ---
        // --- GeoJSON Import Functionality (Removed from here, will be in separate script) ---
    });

})()