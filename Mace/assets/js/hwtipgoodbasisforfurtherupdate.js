// Start Main IIFE to encapsulate the entire combined script and prevent global scope conflicts
(function() {
    // The top-level initialization guard (window.MaceHWTCalculatorInitialized) has been removed.
    // This ensures the script runs fully upon each execution/load, as per your instruction.

    const HWT_HORIZONE_SRC = "K52"; // Specific source ID from horiZONE.html example

    // --- Console Output Override ---
    const originalConsole = { // Capture original console methods
        log: console.log,
        warn: console.warn,
        error: console.error
    };

    // Re-assign console.log/warn/error to use the global displayMessage if needed for consistency
    // Fully re-enable original console logging for direct calls for debugging.
    console.log = function(...args) {
        originalConsole.log(...args);
        // Do NOT route to window.displayMessage here, as it's for specific UI elements.
    };
    console.warn = function(...args) {
        originalConsole.warn(...args);
        // Do NOT route to window.displayMessage here.
    };
    console.error = function(...args) {
        originalConsole.error(...args);
        // Do NOT route to window.displayMessage here.
    };

    // Expose displayMessage and clearResultsDisplay globally for the new export/import script
    window.displayMessage = function(elementId, message, type = 'status') {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = message;
            element.className = `status-message ${type}-message`; // Apply Tailwind classes for styling
        }
        // Log to original console for debugging purposes, but only for explicit displayMessage calls
        originalConsole.log(`Display Message [${type}] for ${elementId || 'N/A'}: ${message}`);
    };


    // --- Leaflet Map and Layer Variables (now referencing global objects from Script B) ---
    // These variables will be assigned from window.map and window.layersControl
    // when the DOM is ready and Script B has initialized them.
    let map = null;
    let layersControl = null;
    let observerMarker = null; // This will now be Script C's own L.CircleMarker

    // Array to hold all LayerGroups created by Script C for easy clearing and GeoJSON export
    // Expose scriptCOverlayGroups globally for the new export/import script
    window.scriptCOverlayGroups = [];

    // Global layer variables for orthodrome and intersection (reintroduced)
    // These are now managed within the processOrthodromeIntersection function scope for each call
    // let ssrOrthodromeLine = null;
    // let ssrOrthodromeEndPointMarker = null;
    // let ssrIntersectionMarker = null;
    // let ssrIntersectionLayerGroup = null;

    /**
     * Clears all dynamically added overlay layers from the map that were generated by Script C.
     * This function now specifically targets layer groups managed by Script C.
     */
    window.clearResultsDisplay = function() { // Made global
        // Iterate over layer groups created by window.scriptCOverlayGroups and remove them
        window.scriptCOverlayGroups.forEach(layerGroup => {
            if (window.map && window.map.hasLayer(layerGroup)) {
                window.map.removeLayer(layerGroup);
            }
            // Remove from layers control if it was added there
            if (window.layersControl && layerGroup.layerNameForControl) {
                window.layersControl.removeLayer(layerGroup);
            }
        });
        // Clear the array of Script C's layer groups
        window.scriptCOverlayGroups = [];

        // Explicitly clear any remaining global orthodrome/intersection layers if they were set outside the groups
        // (Though with refactoring, this section might become less critical if all layers are grouped)
        // if (map && layersControl) {
        //      if (ssrOrthodromeLine && map.hasLayer(ssrOrthodromeLine)) {
        //          map.removeLayer(ssrOrthodromeLine);
        //          layersControl.removeLayer(ssrOrthodromeLine);
        //      }
        //      if (ssrOrthodromeEndPointMarker && map.hasLayer(ssrOrthodromeEndPointMarker)) {
        //          map.removeLayer(ssrOrthodromeEndPointMarker);
        //          layersControl.removeLayer(ssrOrthodromeEndPointMarker);
        //      }
        // }
        // ssrOrthodromeLine = null;
        // ssrOrthodromeEndPointMarker = null;
        // ssrIntersectionMarker = null;
        // ssrIntersectionLayerGroup = null;
    };

    // --- Astronomical Constants ---
    // These are standard apparent altitudes of the SUN'S CENTER relative to the GEOMETRIC HORIZON (0 degrees)
    // when different parts of the sun are at the horizon. They include average atmospheric refraction.
    const SOLAR_REFRACTION = 0.583; // Approx. refraction at horizon for Sun (degrees)
    const SOLAR_SEMIDIAMETER = 0.25; // Approx. semi-diameter of the Sun (degrees)

    // Removed HWT_REFRACTION_COEFFICIENT as refraction is pre-calculated in HWT data and declination values.
    const EARTH_RADIUS_METERS = 6371000; // Earth's mean radius in meters (Still needed for other geodesic calcs if any)

    // Exact azimuthal shift based on user's guidance for 1 degree for full disk (0.51 per semi-diameter)
    // This value is used to calculate the initial azimuth guesses for the center and lower limb,
    // reflecting the horizontal spread of the sun's disk at a geometric horizon.
    const AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT = 0.51; // degrees of azimuth for one solar semi-diameter's worth of altitude change

    // Array of colors for future polygons
    const POLYGON_COLORS = ['orange', 'blue', 'red', 'yellow', 'green'];

    /**
     * Generates points for an orthodrome (great circle path) between a start point and an end point.
     * Overloaded to work from two points or from a start point, bearing, and distance.
     * Based on standard geodesic formulas (similar to Chris Veness's methods).
     * @param {number} lat1 - Start Latitude.
     * @param {number} lon1 - Start Longitude.
     * @param {number} lat2OrBearing - End Latitude OR Bearing in degrees.
     * @param {number} lon2OrDistanceKm - End Longitude OR Distance in kilometers.
     * @param {number} [numPoints=25] - Number of intermediate points to generate for smoothness.
     * @param {number} [bearing=undefined] - Bearing (if using start/bearing/distance overload).
     * @param {number} [distanceKm=undefined] - Distance (if using start/bearing/distance overload).
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for the orthodrome.
     */
    function generateOrthodromePoints(lat1, lon1, lat2OrBearing, lon2OrDistanceKm, numPoints = 25, bearing = undefined, distanceKm = undefined) {
        const points = [];
        points.push([lat1, lon1]);

        let endLat, endLon;
        let totalDistanceRad;

        const R = 6371; // Earth's radius in kilometers
        if (bearing !== undefined && distanceKm !== undefined) { // From start point, bearing, distance
            const brngRad = toRadians(bearing);
            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            totalDistanceRad = distanceKm / R;

            const latRad2 = Math.asin(Math.sin(latRad1) * Math.cos(totalDistanceRad) + Math.cos(latRad1) * Math.sin(totalDistanceRad) * Math.cos(brngRad));
            const lonRad2 = lonRad1 + Math.atan2(Math.sin(brngRad) * Math.sin(totalDistanceRad) * Math.cos(latRad1), Math.cos(totalDistanceRad) - Math.sin(latRad1) * Math.sin(latRad2));

            endLat = toDegrees(latRad2);
            endLon = toDegrees(lonRad2); // Corrected typo: lon2Rad to lonRad2
        } else { // From two points
            endLat = lat2OrBearing;
            endLon = lon2OrDistanceKm;

            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            const latRad2 = toRadians(endLat);
            const lonRad2 = toRadians(endLon);

            // Calculate angular distance for two points (Haversine-like for angular distance)
            const deltaLat = latRad2 - latRad1;
            const deltaLon = lonRad2 - lonRad1;
            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(latRad1) * Math.cos(latRad2) *
                Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
            totalDistanceRad = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        if (totalDistanceRad < 1e-6) { // Points are very close or identical
            points.push([endLat, endLon]);
            return points;
        }

        for (let i = 1; i < numPoints; i++) {
            const f = i / numPoints; // Fraction along the path
            const A = Math.sin((1 - f) * totalDistanceRad) / Math.sin(totalDistanceRad);
            const B = Math.sin(f * totalDistanceRad) / Math.sin(totalDistanceRad);

            const x = A * Math.cos(toRadians(lat1)) * Math.cos(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.cos(toRadians(endLon));
            const y = A * Math.cos(toRadians(lat1)) * Math.sin(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.sin(toRadians(lon2OrDistanceKm));
            const z = A * Math.sin(toRadians(lat1)) + B * Math.sin(toRadians(endLat));

            const lat = Math.atan2(y, x);
            const lon = Math.atan2(y, x);

            points.push([toDegrees(lat), toDegrees(lon)]);
        }
        points.push([endLat, endLon]); // Ensure the exact endpoint is included
        return points;
    }

    /**
     * Interpolates horizon Lat/Lon for a given azimuth.
     * Finds the two horizon data points that bracket the target azimuth and performs linear interpolation.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {{lat: number, lon: number, azimuth: number}|null} Interpolated lat/lon with original azimuth, or null if cannot interpolate.
     */
    function getInterpolatedHorizonLatLon(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = window.normalizeAzimuth(azimuth); // Use window.normalizeAzimuth
        let p1 = null;
        let p2 = null;

        // To handle wrap-around, create an extended version of horizonData
        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        // Find the two horizon data points that bracket the target azimuth
        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            // Adjust p2_az_for_interp if it's a wrap-around to ensure correct ratio calculation
            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            // Adjust targetAz_for_ratio if it's a wrap-around to fit within the p1_az_for_interp to p2_az_for_interp range
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            // --- Robustness: Check for problematic interpolation conditions or NaN values in source points ---
            const isAzimuthDifferenceZero = (p2_az_for_interp === p1_az_for_interp);
            const isP1Invalid = isNaN(p1.horizonLat) || isNaN(p1.horizonLon);
            const isP2Invalid = isNaN(p2.horizonLat) || isNaN(p2.horizonLon);

            if (isAzimuthDifferenceZero || isP1Invalid || isP2Invalid) {
                // Fallback to nearest neighbor if linear interpolation is problematic or data is invalid
                const distToP1 = Math.abs(targetAzimuthNormalized - p1_az_for_interp);
                const distToP2 = Math.abs(targetAzimuthNormalized - p2_az_for_interp);

                let chosenPoint = null;
                if (!isP1Invalid && !isP2Invalid) {
                    // Both are valid, pick the closer one
                    chosenPoint = (distToP1 <= distToP2) ? p1 : p2;
                } else if (!isP1Invalid) {
                    chosenPoint = p1; // Only p1 is valid
                } else if (!isP2Invalid) {
                    chosenPoint = p2; // Only p2 is valid
                }

                if (chosenPoint) {
                    console.warn(`getInterpolatedHorizonLatLon: Linear interpolation problematic (azimuth diff zero or NaN in source). Falling back to nearest neighbor (Azimuth: ${chosenPoint.azimuth.toFixed(3)}°).`);
                    return { lat: chosenPoint.horizonLat, lon: chosenPoint.horizonLon, azimuth: azimuth };
                } else {
                    console.error(`getInterpolatedHorizonLatLon: Cannot interpolate or find nearest valid point for azimuth ${azimuth.toFixed(3)}°. Both source points invalid.`);
                    return null; // Both source points are invalid
                }
            }
            // --- End Robustness ---

            // CORRECTED: Interpolate based on azimuth for latitude and longitude
            const ratio = (targetAz_for_ratio - p1_az_for_interp) / (p2_az_for_interp - p1_az_for_interp);

            const interpolatedLat = p1.horizonLat + ratio * (p2.horizonLat - p1.horizonLat);
            const interpolatedLon = p1.horizonLon + ratio * (p2.horizonLon - p1.horizonLon);

            return { lat: interpolatedLat, lon: interpolatedLon, azimuth: azimuth };
        }
        return null;
    }

    /**
     * Interpolates and returns the altitude of the horizon for a given azimuth.
     * This function is crucial for the iterative search logic.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {number|null} The interpolated altitude, or null if cannot interpolate.
     */
    function getInterpolatedHorizonAltitude(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = window.normalizeAzimuth(azimuth);
        let p1 = null;
        let p2 = null;

        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            // --- Robustness: Check for problematic interpolation conditions or NaN values in source points ---
            const isAzimuthDifferenceZero = (p2_az_for_interp === p1_az_for_interp);
            const isP1AltitudeInvalid = isNaN(p1.altitude);
            const isP2AltitudeInvalid = isNaN(p2.altitude);

            if (isAzimuthDifferenceZero || isP1AltitudeInvalid || isP2AltitudeInvalid) {
                // Fallback to nearest neighbor if linear interpolation is problematic or data is invalid
                const distToP1 = Math.abs(targetAzimuthNormalized - p1_az_for_interp);
                const distToP2 = Math.abs(targetAzimuthNormalized - p2_az_for_interp);

                let chosenPoint = null;
                if (!isP1AltitudeInvalid && !isP2AltitudeInvalid) {
                    // Both are valid, pick the closer one
                    chosenPoint = (distToP1 <= distToP2) ? p1 : p2;
                } else if (!isP1AltitudeInvalid) {
                    chosenPoint = p1; // Only p1 is valid
                } else if (!isP2AltitudeInvalid) {
                    chosenPoint = p2; // Only p2 is valid
                }

                if (chosenPoint) {
                    console.warn(`getInterpolatedHorizonAltitude: Linear interpolation problematic (azimuth diff zero or NaN in source). Falling back to nearest neighbor (Azimuth: ${chosenPoint.azimuth.toFixed(3)}°).`);
                    return chosenPoint.altitude;
                } else {
                    console.error(`getInterpolatedHorizonAltitude: Cannot interpolate or find nearest valid point for azimuth ${azimuth.toFixed(3)}°. Both source points invalid.`);
                    return null; // Both source points are invalid
                }
            }
            // --- End Robustness ---

            const ratio = (targetAz_for_ratio - p1_az_for_interp) / (p2_az_for_interp - p1_az_for_interp);
            const interpolatedAltitude = p1.altitude + ratio * (p2.altitude - p1.altitude);
            return interpolatedAltitude;
        }
        return null;
    }

    // Removed calculateApparentHorizonDip function as per user's instruction (refraction is pre-calculated)


    /**
     * Collects horizon data points that lie azimuthally between two given azimuths,
     * always traversing in a *clockwise (increasing azimuth)* direction, handling 0/360 wrap-around.
     * The points are returned sorted by increasing azimuth.
     * @param {number} startAz - The starting azimuth of the segment (exclusive).
     * @param {number} endAz - The ending azimuth of the segment (exclusive).
     * @param {Array<Object>} horizonData - The full sorted horizon data.
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for points within the range, ordered by increasing azimuth.
     */
    function getIntermediateHorizonPoints(startAz, endAz, horizonData) {
        const points = [];
        if (!horizonData || horizonData.length === 0) {
            return points;
        }

        // Normalize start and end to be within 0-360 for initial range comparison
        const nStart = window.normalizeAzimuth(startAz); // Use window.normalizeAzimuth
        let nEnd = window.normalizeAzimuth(endAz); // Use window.normalizeAzimuth

        // If the intended clockwise range crosses 0/360 (e.g., from 350 to 10), adjust nEnd to be > nStart
        if (nStart > nEnd) {
            nEnd += 360; // Treat as 350 to 370 for comparison
        }

        // Create an extended version of horizonData with azimuths adjusted to cover the full 0-720 range
        // This simplifies range checking for wrapped segments.
        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        // Sort the extended data to ensure iteration is always in increasing azimuth order
        extendedHorizonData.sort((a, b) => a.azimuth - b.azimuth);

        // Iterate through the extended, sorted data
        for (const point of extendedHorizonData) {
            const currentAz = point.azimuth;

            // Include points strictly between start and end (exclusive of endpoints)
            // Use a small tolerance for floating-point comparisons
            if (currentAz > nStart + 0.0001 && currentAz < nEnd - 0.0001) {
                if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                    points.push([point.horizonLat, point.horizonLon]);
                }
            }
        }
        return points;
    }

    /**
     * Draws the viewshed horizon as a polyline using provided lat/lon values.
     * @param {Array<Object>} horizonData - Array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @returns {L.Polyline|null} The created Leaflet Polyline object, or null if invalid data.
     */
    function drawViewshedHorizonLine(horizonData) {
        if (!horizonData || horizonData.length === 0) return null;

        const polylinePoints = [];
        horizonData.forEach(point => {
            if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                polylinePoints.push([point.horizonLat, point.horizonLon]);
            } else {
                console.warn(`Skipping point (Azimuth: ${point.azimuth}) due to invalid horizonLat/Lon values. This point will not be part of the drawn viewshed polyline.`);
            }
        });

        if (polylinePoints.length >= 2) {
            // Close the polyline by adding the first point again at the end, if not already closed
            const firstPoint = polylinePoints[0];
            const lastPoint = polylinePoints[polylinePoints.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                polylinePoints.push(firstPoint);
            }
            console.log(`Viewshed terrain horizon polyline created with ${polylinePoints.length} points.`);
            return L.polyline(polylinePoints, {
                color: '#4299e1', // Blue color for the viewshed horizon line
                weight: 2,
                opacity: 0.7,
                smoothFactor: 1
            });
        } else {
            console.warn("Not enough valid geographical horizon points to draw a polyline.");
            return null;
        }
    }

    /**
     * Draws an individual circle marker on the map for a calculated point.
     * @param {object} point - Object with lat, lon, azimuth properties.
     * @param {string} label - Label for the popup.
     * @param {string} color - The color for the marker (e.g., 'red', 'blue', 'orange').
     * @param {number} [radius=6] - Radius of the marker.
     * @param {number} [fillOpacity=0.0] - Fill opacity of the marker (default to 0 for outline only).
     * @returns {L.CircleMarker|null} The created Leaflet CircleMarker object, or null if invalid point data.
     */
    function drawIndividualPointMarker(point, label, color = 'orange', radius = 6, fillOpacity = 0.0) {
        if (!map || !point || isNaN(point.lat) || isNaN(point.lon) || isNaN(point.azimuth)) {
            return null;
        }

        const marker = L.circleMarker([point.lat, point.lon], {
            radius: radius,
            fillColor: color, // Use provided color
            color: color, // Use provided color for outline
            weight: 2,
            opacity: 1,
            fillOpacity: fillOpacity // Use provided fill opacity
        });
        marker.bindPopup(`<b>${label}</b><br>Azimuth: ${point.azimuth.toFixed(3)}°<br>Lat: ${point.lat.toFixed(6)}<br>Lon: ${point.lon.toFixed(6)}`);
        console.log(`Marker for ${label} created (not yet added to map directly).`);
        return marker;
    }

    /**
     * Converts degrees to radians.
     * @param {number} deg - Degrees.
     * @returns {number} Radians.
     */
    function toRadians(deg) {
        return deg * Math.PI / 180;
    }

    /**
     * Converts radians to degrees.
     * @param {number} rad - Radians.
     * @returns {number} Degrees.
     */
    function toDegrees(rad) {
        return rad * 180 / Math.PI;
    }

    /**
     * Calculates the bearing from one LatLng point to another using LatLon library.
     * @param {L.LatLng} p1 - Start point.
     * @param {L.LatLng} p2 - End point.
     * @returns {number} Bearing in degrees.
     */
    function getBearingBetweenLatLngs(p1, p2) {
        if (typeof LatLon === 'undefined') {
            console.error("LatLon library not available for bearing calculation.");
            return NaN;
        }
        const ll1 = LatLon(p1.lat, p1.lng);
        const ll2 = LatLon(p2.lat, p2.lng);
        return ll1.bearingTo(ll2);
    }

    /**
     * Prepares Leaflet LatLngs for Turf.js by converting to [lng, lat] format.
     * This function performs NO filtering, as per user's strict instruction.
     * Also logs the resulting array to the console.
     * @param {Array<L.LatLng>} leafletLatLngs - Array of Leaflet LatLng objects.
     * @param {string} label - A label for console output (e.g., "Orthodrome", "Viewshed").
     * @returns {Array<Array<number>>} An array of [longitude, latitude] pairs, suitable for Turf.js.
     */
    function getTurfCoordinates(leafletLatLngs, label) {
        const turfCoords = [];
        // Assuming leafletLatLngs is an array of LatLng objects, potentially nested.
        // Access the inner array if present, otherwise assume it's flat.
        const actualLatLngs = (leafletLatLngs.length === 1 && Array.isArray(leafletLatLngs[0]) && typeof leafletLatLngs[0][0] === 'object' && 'lat' in leafletLatLngs[0][0]) ? leafletLatLngs[0] : leafletLatLngs;

        for (let i = 0; i < actualLatLngs.length; i++) {
            const ll = actualLatLngs[i];
            // Directly grab lat and lng. If they are undefined, they will remain undefined.
            const lng = ll ? ll.lng : undefined;
            const lat = ll ? ll.lat : undefined;
            turfCoords.push([lng, lat]);
        }
        // console.log(`${label} coordinates passed to Turf.js (direct access, no filtering):`, turfCoords); // Removed verbose log
        return turfCoords;
    }

    /**
     * Rewritten function: Reformats raw Leaflet LatLng objects (potentially nested array of objects)
     * into an array of [longitude, latitude] pairs for Turf.js.
     * This function performs NO filtering, as per user's strict instruction, and uses direct property access.
     * It logs the reformatted array to the console.
     * @param {Array<any>} rawDataArray - The raw data array, expected to contain LatLng objects, potentially nested.
     * @param {string} label - A label for console output.
     * @returns {Array<Array<number>>} The reformatted array of [longitude, latitude] pairs.
     */
    function reformatAndLogRawLatLngsForTurf(rawDataArray, label) {
        const reformattedCoords = [];
        
        // console.log(`reformatAndLogRawLatLngsForTurf received actual LatLng objects length: ${actualLatLngObjects.length}`); // Removed verbose log
        const actualLatLngObjects = (rawDataArray.length === 1 && Array.isArray(rawDataArray[0]) && typeof rawDataArray[0][0] === 'object' && 'lat' in rawDataArray[0][0]) ? rawDataArray[0] : rawDataArray;

        for (let i = 0; i < actualLatLngObjects.length; i++) {
            const ll = actualLatLngObjects[i]; // This is an individual LatLng object
            
            // Directly grab lat and lng properties. If ll is null/undefined or its properties are,
            // they will remain undefined, as per "no filtering".
            const lng = ll ? ll.lng : undefined;
            const lat = ll ? ll.lat : undefined;

            reformattedCoords.push([lng, lat]);
            // console.log(`    Generated pair for index ${i}: [${lng}, ${lat}]`); // Removed verbose log
        }
        // console.log(`Reformatted RAW ${label} LatLngs for Turf.js (direct access, no filtering):`, reformattedCoords); // Removed verbose log
        return reformattedCoords;
    }

    /**
     * Normalizes an azimuth to be within the 0-360 degree range.
     * Exposed globally to resolve potential ReferenceError.
     * @param {number} az - Azimuth in degrees.
     * @returns {number} Normalized azimuth in degrees (0-360).
     */
    window.normalizeAzimuth = function(az) {
        return (az % 360 + 360) % 360;
    };


    /**
     * Calculates the Sun's celestial altitude and azimuth for a given observer location, declination, and hour angle.
     * Formulas based on spherical astronomy.
     * @param {number} observerLatDeg - Observer's Latitude in Degrees.
     * @param {number} declinationDeg - Sun's Declination in Degrees.
     * @param {number} hourAngleDeg - Hour Angle in Degrees (0 at local meridian, increases westward).
     * @returns {{altitude: number, azimuth: number}|null} Object with altitude and azimuth in degrees, or null if invalid input.
     */
    function calculateSunPosition(observerLatDeg, declinationDeg, hourAngleDeg) {
        if (isNaN(observerLatDeg) || isNaN(declinationDeg) || isNaN(hourAngleDeg)) {
            console.error("Invalid input to calculateSunPosition: NaN detected. Inputs: Lat:", observerLatDeg, "Dec:", declinationDeg, "HA:", hourAngleDeg);
            return null;
        }

        const latRad = toRadians(observerLatDeg);
        const decRad = toRadians(declinationDeg);
        const haRad = toRadians(hourAngleDeg);

        // Calculate Altitude (h)
        // sin(h) = sin(dec)sin(lat) + cos(dec)cos(lat)cos(HA)
        let sinAltitude = Math.sin(decRad) * Math.sin(latRad) +
                            Math.cos(decRad) * Math.cos(latRad) * Math.cos(haRad);
        
        // --- Clamping sinAltitude to [-1, 1] to prevent NaN from Math.asin due to floating point errors ---
        sinAltitude = Math.max(-1, Math.min(1, sinAltitude));
        
        let altitudeRad = Math.asin(sinAltitude); // Altitude in radians

        // Calculate Azimuth (A)
        // cos(A) = (sin(dec) - sin(h)sin(lat)) / (cos(h)cos(lat))
        // Use atan2 for correct quadrant
        const sinAz = -Math.sin(haRad) * Math.cos(decRad);
        const cosAz = Math.sin(decRad) * Math.cos(latRad) - Math.cos(decRad) * Math.sin(latRad) * Math.cos(haRad);
        
        let azimuthRad = Math.atan2(sinAz, cosAz);
        
        // If azimuth is NaN (e.g., due to sinAz and cosAz both being 0), handle it explicitly
        if (isNaN(azimuthRad)) {
            // This happens when the Sun is directly overhead or directly below the observer,
            // where azimuth is undefined. In such cases, we can return NaN for azimuth.
            console.warn(`calculateSunPosition: Azimuth calculation resulted in NaN (sinAz: ${sinAz}, cosAz: ${cosAz}). Returning NaN for azimuth.`);
            return {
                altitude: toDegrees(altitudeRad),
                azimuth: NaN // Return NaN for azimuth, but don't return null for the whole object
            };
        }

        azimuthRad = (azimuthRad + 2 * Math.PI) % (2 * Math.PI); // Normalize to 0 to 2PI (from North, clockwise)

        const result = {
            altitude: toDegrees(altitudeRad),
            azimuth: toDegrees(azimuthRad)
        };

        return result;
    }


    /**
     * Finds the true rise/set azimuth by locating the point on the viewshed horizon
     * whose apparent altitude matches the celestial body's target apparent altitude.
     * This now uses dynamic sun position calculations.
     * Exposed globally to resolve potential ReferenceError.
     * @param {Array<Object>} horizonData - An array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @param {string} targetLimb - 'UL', 'Center', or 'LL' to specify which part of the Sun.
     * @param {number} initialAzimuthGuess - The scenario-specific initial 0-horizon azimuth guess (e.g., from Turf.js intersection).
     * @param {string} scenarioName - A descriptive name for the current calculation scenario (e.g., "Upper Limb").
     * @param {number} observerLat - The observer's latitude.
     * @param {number} observerLon - The observer's longitude.
     * @param {boolean} isSunriseLike - True if it's a sunrise-like event (azimuth increasing), false for sunset-like (azimuth decreasing).
     * @param {number} declinationDeg - The Sun's declination in degrees.
     * @param {number} observerElevationMeters - The observer's elevation above sea level in meters.
     * @returns {{azimuth: number|null, lat: number|null, lon: number: number|null, hourAngle: number}|null} The calculated azimuth, Lat/Lon, and hour angle, or null if no matching point found.
     */
    window.findActualAzimuthForTargetApparentAltitude = async function( // Exposed globally
        horizonData,
        targetLimb, // 'UL', 'Center', 'LL'
        initialAzimuthGuess,
        scenarioName,
        observerLat,
        observerLon,
        isSunriseLike,
        declinationDeg, // New: Declination in degrees
        observerElevationMeters // Observer's elevation in meters (now correctly passed but not used for horizon adjustment)
    ) {
        const TOLERANCE_ALTITUDE = 0.001; // degrees, for matching altitude
        const TIME_STEP_MINUTES = 0.5; // minutes, for iterative time search (e.g., 30 seconds)
        const HOUR_ANGLE_STEP_DEG = TIME_STEP_MINUTES * (360 / (24 * 60)); // Convert minutes to degrees of Hour Angle
        const SEARCH_RANGE_HOURS = 8; // Hours around initial guess to search for event (Increased from 2 to 8)

        // Removed calculation of observerHorizonDip as refraction is pre-calculated in HWT data and declination values.

        function setScenarioStatus(message, type = 'status') {
            console.log(`Display Message [${type}]: ${message}`);
        }
        setScenarioStatus(`Calculating ${scenarioName}...`, 'status');

        if (isNaN(initialAzimuthGuess) || isNaN(declinationDeg)) {
            console.error(`ERROR: Invalid input for ${scenarioName}: initialAzimuthGuess or declination is NaN.`);
            setScenarioStatus(`${scenarioName}: Error: Invalid input.`, 'error');
            return null;
        }

        let minHorizonAlt = Infinity;
        let maxHorizonAlt = -Infinity;
        if (horizonData.length > 0) {
            for (const point of horizonData) {
                if (point.altitude < minHorizonAlt) minHorizonAlt = point.altitude;
                if (point.altitude > maxHorizonAlt) maxHorizonAlt = point.altitude;
            }
        } else {
            console.error(`findActualAzimuthForTargetApparentAltitude (${scenarioName}): Empty horizonData received.`);
            setScenarioStatus(`${scenarioName}: Error: Empty horizon data.`, 'error');
            return null;
        }

        // --- Determine initial hour angle for search based on initialAzimuthGuess ---
        // This is a more robust way to get an initial hour angle for the search.
        // We iterate through a range of hour angles to find the one that produces an azimuth closest to initialAzimuthGuess.
        let bestInitialHAAzimuthDiff = Infinity;
        let bestInitialHA = 0;
        const HA_SEARCH_RESOLUTION = 0.5; // degrees, for initial HA search
        const HA_SEARCH_RANGE = 180; // degrees, search +/- this range around 0HA

        for (let ha = -HA_SEARCH_RANGE; ha <= HA_SEARCH_RANGE; ha += HA_SEARCH_RESOLUTION) {
            const sunPosAtHA = calculateSunPosition(observerLat, declinationDeg, ha);
            if (sunPosAtHA && !isNaN(sunPosAtHA.azimuth)) { // Ensure azimuth is not NaN for comparison
                const diff = Math.abs(window.normalizeAzimuth(sunPosAtHA.azimuth) - window.normalizeAzimuth(initialAzimuthGuess));
                if (diff < bestInitialHAAzimuthDiff) {
                    bestInitialHAAzimuthDiff = diff;
                    bestInitialHA = ha;
                }
            }
        }
        let estimatedInitialHourAngleDeg = bestInitialHA;
        console.log(`${scenarioName}: Estimated initial Hour Angle for search: ${estimatedInitialHourAngleDeg.toFixed(3)}° (closest azimuth match to guess).`);

        // --- Log celestial azimuth of upper limb at estimated initial hour angle ---
        console.log(`${scenarioName}: Inputs for initialSunPosAtEstimatedHA - observerLat: ${observerLat}, declinationDeg: ${declinationDeg}, estimatedInitialHourAngleDeg: ${estimatedInitialHourAngleDeg}`);
        const initialSunPosAtEstimatedHA = calculateSunPosition(observerLat, declinationDeg, estimatedInitialHourAngleDeg);
        if (initialSunPosAtEstimatedHA && !isNaN(initialSunPosAtEstimatedHA.azimuth)) { // Ensure azimuth is not NaN for logging
            let initialSunAltLimbAtEstimatedHA = initialSunPosAtEstimatedHA.altitude;
            if (targetLimb === 'UL') {
                initialSunAltLimbAtEstimatedHA -= SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                initialSunAltLimbAtEstimatedHA += SOLAR_SEMIDIAMETER;
            }
            console.log(`${scenarioName}: Celestial Upper Limb Azimuth at estimated initial HA (${estimatedInitialHourAngleDeg.toFixed(3)}°): ${initialSunPosAtEstimatedHA.azimuth.toFixed(3)}°`);
            console.log(`${scenarioName}: Celestial Limb Altitude at estimated initial HA: ${initialSunAltLimbAtEstimatedHA.toFixed(3)}°`);
        } else {
            console.error(`${scenarioName}: initialSunPosAtEstimatedHA is NULL or its azimuth is NaN. Check inputs and calculateSunPosition logic. Result: ${JSON.stringify(initialSunPosAtEstimatedHA)}`);
        }
        // --- END NEW ---


        let bestMatch = null;
        let foundCrossing = false;

        // Iterate over a range of hour angles (e.g., +/- SEARCH_RANGE_HOURS around the estimated initial HA)
        const totalSteps = (SEARCH_RANGE_HOURS * 2 * 60) / TIME_STEP_MINUTES;
        const startHourAngle = estimatedInitialHourAngleDeg - (SEARCH_RANGE_HOURS * (360 / 24)); // Start X hours before estimated
        const endHourAngle = estimatedInitialHourAngleDeg + (SEARCH_RANGE_HOURS * (360 / 24)); // End X hours after estimated

        let prevSunAltLimb = null;
        let prevTerrainAlt = null; // This will store the *adjusted* terrain altitude
        let prevHourAngle = null;

        for (let i = 0; i <= totalSteps; i++) {
            const currentHourAngle = startHourAngle + (i * HOUR_ANGLE_STEP_DEG);
            const sunPos = calculateSunPosition(observerLat, declinationDeg, currentHourAngle);

            // Skip if sun position calculation failed or azimuth is NaN
            if (!sunPos || isNaN(sunPos.azimuth)) {
                console.warn(`${scenarioName}: Skipping step ${i} due to invalid sun position (azimuth is NaN).`);
                continue;
            }

            let sunAltitudeLimb = sunPos.altitude;
            if (targetLimb === 'UL') {
                sunAltitudeLimb -= SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                sunAltitudeLimb += SOLAR_SEMIDIAMETER;
            }
            // Note: Atmospheric refraction is assumed to be handled by the "apparent" nature of HWT altitudes.

            let terrainAltitude = getInterpolatedHorizonAltitude(sunPos.azimuth, horizonData);

            if (terrainAltitude === null) {
                console.warn(`${scenarioName}: Could not interpolate terrain altitude at azimuth ${sunPos.azimuth.toFixed(3)}°. Skipping.`);
                prevSunAltLimb = sunAltitudeLimb;
                prevTerrainAlt = null; // Reset prevTerrainAlt if interpolation fails
                prevHourAngle = currentHourAngle;
                continue;
            }

            // Removed: No longer adjusting terrainAltitude by observerHorizonDip as refraction is pre-calculated in HWT data.
            // terrainAltitude -= observerHorizonDip;

            const isSunAboveTerrain = sunAltitudeLimb > terrainAltitude;

            // --- Log step-by-step comparison values ---
            console.log(`  Step ${i}: HA=${currentHourAngle.toFixed(3)}°, SunAz=${sunPos.azimuth.toFixed(3)}°, SunLimbAlt=${sunAltitudeLimb.toFixed(3)}°, TerrainAlt (raw HWT)=${terrainAltitude.toFixed(3)}°, isSunAboveTerrain=${isSunAboveTerrain}`);
            // --- END NEW ---

            if (prevSunAltLimb !== null && prevTerrainAlt !== null && prevHourAngle !== null) {
                const wasSunAboveTerrain = prevSunAltLimb > prevTerrainAlt;

                // Check for crossing: Sun's limb altitude relative to terrain altitude
                // For rise: Sun's limb goes from below terrain to above terrain
                // For set: Sun's limb goes from above terrain to below terrain
                const hasCrossed = (isSunriseLike && !wasSunAboveTerrain && isSunAboveTerrain) ||
                                   (!isSunriseLike && wasSunAboveTerrain && !isSunAboveTerrain);

                // --- Log hasCrossed ---
                console.log(`  Step ${i}: hasCrossed=${hasCrossed}`);
                // --- END NEW ---

                if (hasCrossed) {
                    foundCrossing = true;
                    // Perform a finer search within this segment [prevHourAngle, currentHourAngle]
                    let lowHA = prevHourAngle;
                    let highHA = currentHourAngle;
                    let fineSearchIterations = 0;
                    const MAX_FINE_SEARCH_ITERATIONS = 150; // Increased from 50 to 150

                    let finalHA = null;
                    let lastMidHA = null; // Store the last midHA calculated during fine search

                    while (fineSearchIterations < MAX_FINE_SEARCH_ITERATIONS) {
                        const midHA = (lowHA + highHA) / 2;
                        lastMidHA = midHA; // Update lastMidHA

                        const midSunPos = calculateSunPosition(observerLat, declinationDeg, midHA);
                        // Break if sun position can't be calculated or azimuth is NaN
                        if (!midSunPos || isNaN(midSunPos.azimuth)) {
                            console.warn(`${scenarioName}: Fine search failed to calculate sun position (azimuth is NaN) at ${midHA.toFixed(3)}°. Breaking fine search.`);
                            break;
                        }

                        let midSunAltLimb = midSunPos.altitude;
                        if (targetLimb === 'UL') {
                            midSunAltLimb -= SOLAR_SEMIDIAMETER;
                        } else if (targetLimb === 'LL') {
                            midSunAltLimb += SOLAR_SEMIDIAMETER;
                        }

                        let midTerrainAlt = getInterpolatedHorizonAltitude(midSunPos.azimuth, horizonData);
                        if (midTerrainAlt === null) {
                            console.warn(`${scenarioName}: Fine search failed to interpolate terrain at ${midSunPos.azimuth.toFixed(3)}°. Breaking fine search.`);
                            break; // Break if terrain interpolation fails
                        }
                        // Removed: No longer adjusting midTerrainAlt by observerHorizonDip
                        // midTerrainAlt -= observerHorizonDip;

                        const currentDifference = midSunAltLimb - midTerrainAlt;

                        if (Math.abs(currentDifference) < TOLERANCE_ALTITUDE) {
                            finalHA = midHA;
                            break;
                        }

                        // Adjust search range based on whether Sun is above or below terrain
                        if (isSunriseLike) { // For rise, we want Sun to go from below to above terrain
                            if (currentDifference < 0) { // Sun is still below terrain
                                lowHA = midHA;
                            } else { // Sun is above terrain
                                highHA = midHA;
                            }
                        } else { // For set, we want Sun to go from above to below terrain
                            if (currentDifference > 0) { // Sun is still above terrain
                                lowHA = midHA;
                            } else { // Sun is below terrain
                                highHA = midHA;
                            }
                        }
                        fineSearchIterations++;
                    }

                    // Fallback mechanism: If fine search failed to converge precisely but a crossing was found
                    if (finalHA === null && foundCrossing && lastMidHA !== null) {
                        const fallbackSunPos = calculateSunPosition(observerLat, declinationDeg, lastMidHA);
                        if (fallbackSunPos && !isNaN(fallbackSunPos.azimuth)) {
                            finalHA = lastMidHA; // Use the last approximated hour angle
                            console.warn(`${scenarioName}: Fine search did not converge precisely, using last approximated hour angle (${finalHA.toFixed(3)}°) as fallback.`);
                        } else {
                            console.warn(`${scenarioName}: Fallback HA (${lastMidHA.toFixed(3)}°) led to invalid sun position. Cannot use fallback.`);
                            finalHA = null; // Invalidate finalHA if fallback is also problematic
                        }
                    }


                    if (finalHA !== null) {
                        const finalSunPos = calculateSunPosition(observerLat, declinationDeg, finalHA);
                        if (finalSunPos && !isNaN(finalSunPos.azimuth)) { // Ensure final sun position and its azimuth are valid
                            const finalPointLatLon = getInterpolatedHorizonLatLon(finalSunPos.azimuth, horizonData);
                            if (finalPointLatLon && !isNaN(finalPointLatLon.lat) && !isNaN(finalPointLatLon.lon)) { // Ensure final Lat/Lon are valid
                                setScenarioStatus(`${scenarioName}: Actual Azimuth calculated.`, 'success');
                                return {
                                    azimuth: finalSunPos.azimuth,
                                    lat: finalPointLatLon.lat,
                                    lon: finalPointLatLon.lon,
                                    hourAngle: finalHA
                                };
                            } else {
                                console.warn(`${scenarioName}: Could not interpolate final horizon Lat/Lon for calculated azimuth ${finalSunPos.azimuth.toFixed(3)}° (Lat/Lon might be NaN). Returning null.`);
                                return null; // Return null if Lat/Lon interpolation fails for the final point
                            }
                        } else {
                            console.warn(`${scenarioName}: Failed to calculate final sun position for hour angle ${finalHA.toFixed(3)}° (azimuth might be NaN). Returning null.`);
                            return null; // Return null if final sun position calculation fails or azimuth is NaN
                        }
                    }
                }
            }

            prevSunAltLimb = sunAltitudeLimb;
            prevTerrainAlt = terrainAltitude;
            prevHourAngle = currentHourAngle;
        }

        // If we reach here, it means 'foundCrossing' remained false throughout the main loop.
        // Now, determine *why* it remained false and return null.
        const finalSunPosCheck = calculateSunPosition(observerLat, declinationDeg, estimatedInitialHourAngleDeg);
        if (finalSunPosCheck && !isNaN(finalSunPosCheck.azimuth)) { // Ensure azimuth is valid for final check
            let finalSunAltLimbCheck = finalSunPosCheck.altitude;
            if (targetLimb === 'UL') {
                finalSunAltLimbCheck -= SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                finalSunAltLimbCheck += SOLAR_SEMIDIAMETER;
            }
            const finalTerrainAltCheck = getInterpolatedHorizonAltitude(finalSunPosCheck.azimuth, horizonData);

            if (finalTerrainAltCheck !== null) {
                // Removed: No longer adjusting finalTerrainAltCheck by observerHorizonDip
                // const adjustedFinalTerrainAltCheck = finalTerrainAltCheck - observerHorizonDip;

                if (finalSunAltLimbCheck < finalTerrainAltCheck - TOLERANCE_ALTITUDE) {
                    // Corrected message: Sun is below terrain, so it's blocked.
                    setScenarioStatus(`${scenarioName}: Object appears to be always BLOCKED by terrain in the expanded search range. No rise event detected.`, 'error');
                } else if (finalSunAltLimbCheck > finalTerrainAltCheck + TOLERANCE_ALTITUDE) {
                    // Corrected message: Sun is above terrain, so it's clear.
                    setScenarioStatus(`${scenarioName}: Object appears to be always CLEAR of terrain in the expanded search range. No set event detected.`, 'warn');
                } else {
                    // This case is unlikely if TOLERANCE_ALTITUDE is small and no crossing was found,
                    // but it covers scenarios where it's exactly at horizon or very close without crossing.
                    setScenarioStatus(`${scenarioName}: Object remains at or near horizon throughout search range; no clear crossing detected.`, 'warn');
                }
            } else {
                 setScenarioStatus(`${scenarioName}: Could not interpolate terrain altitude at initial guess azimuth. No event calculated.`, 'error');
            }
        } else {
            console.error(`${scenarioName}: Failed to calculate initial sun position for final check (azimuth might be NaN). No event calculated.`);
            setScenarioStatus(`${scenarioName}: Failed to calculate initial sun position for final check. No event calculated.`, 'error');
        }

        console.error(`Critical (${scenarioName}): No valid terrain-adjusted event found after iterative search.`);
        return null; // Always return null if no crossing was found and returned earlier.
    };


    /**
     * Finds the intersection point on the viewshed horizon for a given orthodromic line using Turf.js.
     * @param {L.LatLng} observerLatLng - The observer's location.
     * @param {Array<Array<number>>} orthodromeCoordsTurf - Array of [longitude, latitude] for the orthodromic line.
     * @param {Array<Array<number>>} viewshedCoordsTurf - Array of [longitude, latitude] for the viewshed horizon.
     * @returns {{lat: number, lon: number, azimuth: number}|null} The intersection point, or null if not found.
     */
    function findOrthodromeViewshedIntersection(observerLatLng, orthodromeCoordsTurf, viewshedCoordsTurf) {
        if (typeof turf === 'undefined') {
            console.error("Turf.js library not loaded. Cannot perform line intersection.");
            return null;
        }

        // --- Filter out invalid coordinates before passing to turf.lineString ---
        const validOrthodromeCoords = orthodromeCoordsTurf.filter(coords => 
            typeof coords[0] === 'number' && !isNaN(coords[0]) &&
            typeof coords[1] === 'number' && !isNaN(coords[1])
        );
        const validViewshedCoords = viewshedCoordsTurf.filter(coords => 
            typeof coords[0] === 'number' && !isNaN(coords[0]) &&
            typeof coords[1] === 'number' && !isNaN(coords[1])
        );

        // console.log("Orthodrome coordinates provided to turf.lineString (filtered for validity):", validOrthodromeCoords); // Removed verbose log
        // console.log("Viewshed coordinates provided to turf.lineString (filtered for validity):", validViewshedCoords); // Removed verbose log

        // Check if there are enough valid coordinates after filtering
        if (validOrthodromeCoords.length < 2 || validViewshedCoords.length < 2) {
            console.warn("Insufficient valid coordinates after filtering for Turf.js intersection. Skipping intersection.");
            return null;
        }

        // The coordinates are now guaranteed to be valid numbers for turf.lineString
        const turfOrthodrome = turf.lineString(validOrthodromeCoords);
        const turfViewshed = turf.lineString(validViewshedCoords);

        // Find intersections
        const intersections = turf.lineIntersect(turfOrthodrome, turfViewshed);

        if (intersections.features.length > 0) {
            // Pick the first intersection point (closest to the start of the orthodrome)
            const intersectionCoords = intersections.features[0].geometry.coordinates;
            
            // Per user instruction, no explicit validation or parseFloat here.
            const intersectionLat = intersectionCoords[1];
            const intersectionLon = intersectionCoords[0];

            const intersectionLatLng = L.latLng(intersectionLat, intersectionLon);

            const actualIntersectionAzimuth = getBearingBetweenLatLngs(observerLatLng, intersectionLatLng);
            
            // console.log("Turf.js Intersection found at Lat: " + intersectionLat.toFixed(6) + ", Lon: " + intersectionLon.toFixed(6) + ", Azimuth: " + actualIntersectionAzimuth.toFixed(3) + "°"); // Removed verbose log
            return {
                lat: intersectionLat,
                lon: intersectionLon,
                azimuth: actualIntersectionAzimuth
            };
        }

        return null; // No intersection found
    }

    /**
     * Helper function to process orthodrome intersection for a given state.
     * @param {number} zeroHorizonAzimuth - The 0-horizon azimuth for this state.
     * @param {object} locationData - Observer's location data.
     * @param {L.Polyline} viewshedPolyline - The viewshed polyline.
     * @param {string} scenarioName - Name of the scenario (e.g., "SSR").
     * @param {string} layerGroupName - Name for the layer group.
     * @returns {{azimuth: number, lat: number, lon: number}|null} The intersection point, or null.
     */
    async function processOrthodromeIntersection(zeroHorizonAzimuth, locationData, viewshedPolyline, scenarioName, layerGroupName) {
        let orthodromeLatLngsForGeodesic = [];
        let rawGeodesicLatLngs = [];
        let intersectionPoint = null;

        if (!isNaN(zeroHorizonAzimuth) && locationData && typeof LatLon !== 'undefined' && typeof L.geodesic !== 'undefined') {
            const observerLat = locationData.latitude;
            const observerLon = locationData.longitude;
            const lineDistanceKm = 200; // Sufficient distance to cross most horizons

            const startPointLatLon = LatLon(observerLat, observerLon);
            const endPointLatLon = startPointLatLon.destinationPoint(lineDistanceKm * 1000, zeroHorizonAzimuth);

            if (isNaN(endPointLatLon.lat) || isNaN(endPointLatLon.lon)) {
                console.warn(`Calculated orthodrome end point for ${scenarioName} is invalid (NaN).`);
                orthodromeLatLngsForGeodesic = [L.latLng(observerLat, observerLon), L.latLng(NaN, NaN)];
            } else {
                orthodromeLatLngsForGeodesic = [
                    L.latLng(observerLat, observerLon),
                    L.latLng(endPointLatLon.lat, endPointLatLon.lon)
                ];
            }

            let tempOrthodromeLine = L.geodesic(orthodromeLatLngsForGeodesic, {
                steps: 100
            });

            rawGeodesicLatLngs = tempOrthodromeLine.getLatLngs();
            // console.log(`Raw Geodesic Orthodrome Attempt LatLngs for ${scenarioName}:`, rawGeodesicLatLngs); // Removed verbose log

            const reformattedOrthodromeCoords = reformatAndLogRawLatLngsForTurf(rawGeodesicLatLngs, `Geodesic Orthodrome Attempt for ${scenarioName}`);

            if (viewshedPolyline && typeof turf !== 'undefined') {
                const viewshedActualLatLngs = viewshedPolyline.getLatLngs();
                const filteredViewshedCoordsTurf = getTurfCoordinates(viewshedActualLatLngs, `Viewshed Horizon for ${scenarioName}`);
                const observerLatLng = L.latLng(locationData.latitude, locationData.longitude);

                intersectionPoint = findOrthodromeViewshedIntersection(observerLatLng, reformattedOrthodromeCoords, filteredViewshedCoordsTurf);

                if (intersectionPoint) {
                    let intersectionMarker = drawIndividualPointMarker(intersectionPoint, `${scenarioName} Orthodrome Intersection`, 'orange', 3, 1);
                    if (intersectionMarker) {
                        let intersectionLayerGroup = L.layerGroup();
                        intersectionLayerGroup.addLayer(intersectionMarker);
                        intersectionLayerGroup.layerNameForControl = `${scenarioName} Orthodrome Intersection`;
                        
                        map.addLayer(intersectionLayerGroup);
                        layersControl.addOverlay(intersectionLayerGroup, intersectionLayerGroup.layerNameForControl);
                        window.scriptCOverlayGroups.push(intersectionLayerGroup);
                        // console.log(`Intersection marker layer group added to map for ${scenarioName}.`); // Removed verbose log
                    }
                } else {
                    console.warn(`No intersection found between ${scenarioName} Orthodrome and Viewshed Horizon, or data invalid.`);
                }
            } else {
                console.warn(`Cannot find intersection for ${scenarioName}: Viewshed Horizon line not available, or Turf.js not loaded.`);
            }
        } else {
            console.warn(`Cannot process Orthodrome data for ${scenarioName}: base azimuth or location data invalid, or LatLon/L.geodesic not available.`);
        }
        return intersectionPoint;
    }


    /**
     * Fetches location data (lat, lon, elev_amsl) for a specific ID from heywhatsthat.com's result.json.
     * (Retained for observer location data)
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<{latitude: number, longitude: number, elevation_amsl: number}|null>} Parsed location info.
     */
    async function fetchLocationData(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/bin/result.json?id=${hwtId}`;

        window.displayMessage('locationStatus', `Fetching location data for ID: ${hwtId} from /bin/result.json...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const json = JSON.parse(text);

            const lat = parseFloat(json?.lat);
            const lon = parseFloat(json?.lon);
            const elev_amsl = parseFloat(json?.elev_amsl);

            if (!isNaN(lat) && !isNaN(lon) && !isNaN(elev_amsl)) {
                window.displayMessage('locationStatus', 'Location data fetched successfully.', 'success-message');
                return { latitude: lat, longitude: lon, elevation_amsl: elev_amsl };
            }
            throw new Error("Missing or invalid 'lat', 'lon', or 'elev_amsl' in JSON response.");

        } catch (error) {
            window.displayMessage('locationStatus', 'Error fetching location data.', 'error-message');
            window.displayMessage('locationError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching location data:", error);
            return null;
        }
    }

    /**
     * Fetches and parses viewshed data from heywhatsthat.com's horizon.csv API.
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<Array<Object>>} A promise resolving to an array of {azimuth, altitude, horizonLat?, horizonLon?} objects.
     */
    async function fetchHorizonDataHoriZONE(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/api/horizon.csv?id=${hwtId}&resolution=.125&src=${HWT_HORIZONE_SRC}&keep=1`;

        window.displayMessage('viewshedStatus', `Fetching viewshed data for ID: ${hwtId} from /api/horizon.csv (horiZONE method)...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const lines = text.trim().split('\n');
            const horizonData = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#') || line === '') continue;

                const parts = line.split(',').map(s => s.trim());
                // Expecting: "bin bottom",azimuth,altitude,"distance (m)",latitude,longitude,"elevation (m amsl)"
                if (parts.length >= 6) {
                    // CORRECTED MAPPING:
                    const azimuth = parseFloat(parts[1]); // Azimuth is now in parts[1]
                    const altitude = parseFloat(parts[2]); // Altitude is now in parts[2]
                    const horizonLat = parseFloat(parts[4]); // Latitude is in parts[4]
                    const horizonLon = parseFloat(parts[5]); // Longitude is in parts[5]

                    if (!isNaN(azimuth) && !isNaN(altitude) && !isNaN(horizonLat) && !isNaN(horizonLon)) {
                        horizonData.push({ azimuth, altitude, horizonLat, horizonLon });
                    } else {
                        console.warn(`Skipping line ${i} due to invalid number parsing (az:${parts[1]}, alt:${parts[2]}, lat:${parts[4]}, lon:${parts[5]}): ${line}`);
                    }
                } else {
                    console.warn(`Skipping line ${i} due to insufficient columns (${parts.length} < 6): ${line}`);
                }
            }

            if (horizonData.length === 0) {
                throw new Error("No valid azimuth-altitude-lat-lon pairs parsed from horizon.csv. Response might be malformed or empty data.");
            }

            horizonData.sort((a, b) => a.azimuth - b.azimuth);
            window.displayMessage('viewshedStatus', 'Viewshed data fetched successfully.', 'success-message');
            return horizonData;

        } catch (error) {
            window.displayMessage('viewshedStatus', 'Error fetching viewshed data.', 'error-message');
            window.displayMessage('viewshedError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching viewshed data:", error);
            return null;
        }
    }

    /**
     * Deduplicates an array of horizon data objects based on unique latitude and longitude pairs.
     * It keeps the first occurrence of a unique lat/lon pair.
     *
     * @param {Array<Object>} horizonData - An array of objects, where each object is expected
     * to have 'horizonLat' and 'horizonLon' properties.
     * @returns {Array<Object>} A new array containing only unique horizon data points based on lat/lon.
     */
    function deduplicateHorizonData(horizonData) {
        if (!horizonData || !Array.isArray(horizonData) || horizonData.length === 0) {
            console.warn("deduplicateHorizonData: Input is not a valid array or is empty. Returning empty array.");
            return [];
        }

        const seenLocations = new Set(); // To store unique "lat,lon" strings
        const uniqueData = [];            // To store the deduplicated objects

        for (const point of horizonData) {
            // Ensure point and its properties exist and are numbers before processing
            if (point && typeof point.horizonLat === 'number' && !isNaN(point.horizonLat) &&
                typeof point.horizonLon === 'number' && !isNaN(point.horizonLon)) {

                // Create a unique string key for the latitude and longitude
                // Using a fixed number of decimal places for consistency and to avoid floating-point comparison issues
                const key = `${point.horizonLat.toFixed(6)},${point.horizonLon.toFixed(6)}`;

                if (!seenLocations.has(key)) {
                    seenLocations.add(key);
                    uniqueData.push(point);
                } else {
                    // console.log(`Deduplicate: Skipping duplicate Lat/Lon: ${key} (Azimuth: ${point.azimuth})`); // Removed verbose log
                }
            } else {
                console.warn("deduplicateHorizonData: Skipping invalid point (missing/non-numeric lat/lon):", point);
            }
        }

        console.log(`Deduplication complete. Original size: ${horizonData.length}, Unique size: ${uniqueData.length}`);
        return uniqueData;
    }


    // Helper function to create and add a polygon layer group
    async function createAndAddPolygonLayer(
        initialAzimuthUL, initialAzimuthCenter, initialAzimuthLL,
        horizonData, locationData, polygonColor, scenarioName, layerGroupName,
        isSunriseLike, declinationDeg // New: isSunriseLike and declinationDeg
    ) {
        const observerLatLng = [locationData.latitude, locationData.longitude];
        const observerElevationMeters = locationData.elevation_amsl; // Get observer elevation

        // The initialAzimuthUL, initialAzimuthCenter, initialAzimuthLL are now used as initial guess for the time-based search
        // CORRECTED: Swapped 'UL' with 'LL' and vice-versa based on user feedback
        const actualPointUL = await window.findActualAzimuthForTargetApparentAltitude(
            horizonData, 'LL', initialAzimuthUL, `${scenarioName} Lower Limb at Horizon`, locationData.latitude, locationData.longitude, isSunriseLike, declinationDeg, observerElevationMeters
        );
        const actualPointCenter = await window.findActualAzimuthForTargetApparentAltitude(
            horizonData, 'Center', initialAzimuthCenter, `${scenarioName} Center at Horizon`, locationData.latitude, locationData.longitude, isSunriseLike, declinationDeg, observerElevationMeters
        );
        const actualPointLL = await window.findActualAzimuthForTargetApparentAltitude(
            horizonData, 'UL', initialAzimuthLL, `${scenarioName} Upper Limb at Horizon`, locationData.latitude, locationData.longitude, isSunriseLike, declinationDeg, observerElevationMeters
        );

        let layerGroup = L.layerGroup();
        layerGroup.layerNameForControl = layerGroupName; // Store name for layers control

        let anyPointMissing = !(actualPointUL && actualPointCenter && actualPointLL);
        if (anyPointMissing) {
            console.warn(`Cannot draw ${scenarioName} polygon: one or more critical points are missing.`);
            return { layerGroup: layerGroup, success: false };
        }

        const polygonLatLngs = [];
        polygonLatLngs.push(observerLatLng);

        // console.log(`Adding ${scenarioName} UL point to polygon: ${actualPointUL.lat.toFixed(6)}, ${actualPointUL.lon.toFixed(6)}`); // Removed verbose log
        polygonLatLngs.push([actualPointUL.lat, actualPointUL.lon]);

        // Add intermediate points between UL and Center
        let pointsBetweenULCenter;
        if (isSunriseLike) {
            pointsBetweenULCenter = getIntermediateHorizonPoints(actualPointUL.azimuth, actualPointCenter.azimuth, horizonData);
            // pointsBetweenULCenter.forEach(p => { console.log(`Adding intermediate point (${scenarioName} UL-Center): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed verbose log
        } else { // Sunset-like, traverse counter-clockwise for intermediate points
            pointsBetweenULCenter = getIntermediateHorizonPoints(actualPointCenter.azimuth, actualPointUL.azimuth, horizonData);
            // pointsBetweenULCenter.reverse().forEach(p => { console.log(`Adding intermediate point (${scenarioName} UL-Center, reversed): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed verbose log
        }
        pointsBetweenULCenter.forEach(p => polygonLatLngs.push(p)); // Add points to polygon

        // console.log(`Adding ${scenarioName} Center point to polygon: ${actualPointCenter.lat.toFixed(6)}, ${actualPointCenter.lon.toFixed(6)}`); // Removed verbose log
        polygonLatLngs.push([actualPointCenter.lat, actualPointCenter.lon]);

        // Add intermediate points between Center and LL
        let pointsBetweenCenterLL;
        if (isSunriseLike) {
            pointsBetweenCenterLL = getIntermediateHorizonPoints(actualPointCenter.azimuth, actualPointLL.azimuth, horizonData);
            // pointsBetweenCenterLL.forEach(p => { console.log(`Adding intermediate point (${scenarioName} Center-LL): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed verbose log
        } else { // Sunset-like, traverse counter-clockwise for intermediate points
            pointsBetweenCenterLL = getIntermediateHorizonPoints(actualPointLL.azimuth, actualPointCenter.azimuth, horizonData);
            // pointsBetweenCenterLL.reverse().forEach(p => { console.log(`Adding intermediate point (${scenarioName} Center-LL, reversed): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed verbose log
        }
        pointsBetweenCenterLL.forEach(p => polygonLatLngs.push(p)); // Add points to polygon

        // console.log(`Adding ${scenarioName} LL point to polygon: ${actualPointLL.lat.toFixed(6)}, ${actualPointLL.lon.toFixed(6)}`); // Removed verbose log
        polygonLatLngs.push([actualPointLL.lat, actualPointLL.lon]);

        polygonLatLngs.push(observerLatLng); // Close the polygon

        const polygon = L.polygon(polygonLatLngs, {
            color: polygonColor,
            weight: 2,
            opacity: 1,
            dashArray: '5, 10',
            fillColor: polygonColor,
            fillOpacity: 0.1
        });
        layerGroup.addLayer(polygon);

        // Add individual markers to the layer group
        layerGroup.addLayer(drawIndividualPointMarker(actualPointUL, `${scenarioName} Upper Limb`, polygonColor));
        layerGroup.addLayer(drawIndividualPointMarker(actualPointCenter, `${scenarioName} Center`, polygonColor));
        layerGroup.addLayer(drawIndividualPointMarker(actualPointLL, `${scenarioName} Lower Limb`, polygonColor));

        // Add the layer group to the map and layers control
        window.map.addLayer(layerGroup);
        window.layersControl.addOverlay(layerGroup, layerGroupName);
        window.scriptCOverlayGroups.push(layerGroup); // Add to Script C's managed layers

        return { layerGroup: layerGroup, success: true };
    }


    // --- Event Listener for Form Submission ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Assign global map and layersControl from Script B once DOM is ready
        map = window.map;
        layersControl = window.layersControl;
        observerMarker = window.bigMarker; // Script B's draggable marker

        const form = document.getElementById('azimuthForm');
        const hwtIdentifierInput = document.getElementById('hwtIdentifierInput');
        const loadingSpinner = document.getElementById('loadingSpinner');

        form.addEventListener('submit', async (e) => {
            e.preventDefault(); // Prevent default form submission behavior (page reload)

            // console.log("Summer Solstice Declination (from window.declinationSummerSolstice):", window.declinationSummerSolstice ? window.declinationSummerSolstice.toFixed(4) : "undefined/null"); // Removed verbose log
            // console.log("Winter Solstice Declination (from window.declinationWinterSolstice):", window.declinationWinterSolstice ? window.declinationWinterSolstice.toFixed(4) : "undefined/null"); // Removed verbose log

            window.clearResultsDisplay(); // Use global clearResultsDisplay
            window.displayMessage('overallStatus', 'Starting terrain-adjusted azimuth calculation...', 'status');
            if (loadingSpinner) loadingSpinner.classList.remove('hidden');

            const hwtId = hwtIdentifierInput.value.trim();

            if (!hwtId) {
                window.displayMessage('overallStatus', 'Error: Please enter a HeyWhatsThat Identifier.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return; // Exit early if hwtId is empty
            }

            let locationData = null;
            let horizonData = null;
            let anyCalculationFailed = false;

            // --- Fetch Location Data ---
            locationData = await fetchLocationData(hwtId);
            if (!locationData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch location data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // Update Script B's map and marker with fetched location data
            // This is for visual consistency, not for calculation input in Script C.
            if (map && observerMarker) {
                map.setView([locationData.latitude, locationData.longitude], map.getZoom());
                observerMarker.setLatLng([locationData.latitude, locationData.longitude]);
                document.getElementById('latbox').value = locationData.latitude;
                document.getElementById('lngbox').value = locationData.longitude;
                observerMarker.bindPopup(`<b>Observer Location</b><br>Lat: ${locationData.latitude.toFixed(4)}, Lon: ${locationData.longitude.toFixed(4)}`).openPopup();
            } else {
                console.error("Leaflet map or observer marker not available from Script B.");
                window.displayMessage('overallStatus', 'Error: Map components not ready.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- Fetch Viewshed Data ---
            horizonData = await fetchHorizonDataHoriZONE(hwtId);
            if (!horizonData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch viewshed data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- NEW: Deduplicate horizon data ---
            horizonData = deduplicateHorizonData(horizonData);
            // --- END NEW ---

            window.displayMessage('overallStatus', "Calculating actual azimuths...", 'status');

            // --- Viewshed Horizon Line ---
            const viewshedPolyline = drawViewshedHorizonLine(horizonData);
            if (viewshedPolyline) {
                let viewshedHorizonLineGroup = L.layerGroup();
                viewshedHorizonLineGroup.addLayer(viewshedPolyline);
                viewshedHorizonLineGroup.layerNameForControl = "Viewshed Horizon"; // Name for layers control
                window.map.addLayer(viewshedHorizonLineGroup);
                window.layersControl.addOverlay(viewshedHorizonLineGroup, viewshedHorizonLineGroup.layerNameForControl);
                window.scriptCOverlayGroups.push(viewshedHorizonLineGroup);
            }

            // --- Read Mapped Azimuth Values from Script A's Global Variables ---
            // These values are now correctly read directly from the global JavaScript variables
            // that Script A populates. NO .value or parseFloat needed here.
            let wsrZeroHorizonAzimuth = window.solsticeaziwinrise;
            let wssZeroHorizonAzimuth = window.solsticeaziwinset;
            let ssrZeroHorizonAzimuth = window.solsticeazisumrise;
            let sssZeroHorizonAzimuth = window.solsticeazisumset;
            let ncqrZeroHorizonAzimuth = window.crossquarterazisumrise;
            let scqrZeroHorizonAzimuth = window.crossquarteraziwinrise;
            let ncqsZeroHorizonAzimuth = window.crossquarterazisumset;
            let scqsZeroHorizonAzimuth = window.crossquarteraziwinset;
            let nmlrZeroHorizonAzimuth = window.majorazisumrise;
            let nmlsZeroHorizonAzimuth = window.majorazisumset;
            let smlrZeroHorizonAzimuth = window.majoraziwinrise;
            let smnlsZeroHorizonAzimuth_major = window.majoraziwinset; // Renamed to avoid collision
            let nmnlrZeroHorizonAzimuth = window.minorazisumrise;
            let smnlrZeroHorizonAzimuth = window.minorazisumrise;
            let nmnlsZeroHorizonAzimuth = window.minorazisumset;
            let smnlsZeroHorizonAzimuth_minor = window.minoraziwinset; // Renamed to avoid collision
            let erZeroHorizonAzimuth = window.equinoxazisumrise;
            let esZeroHorizonAzimuth = window.equinoxazisumset;
            // --- END MAPPED AZIMUTH VALUES ---

            // --- Get Declination Values from Script A's global variables ---
            const declinationDegSSR = window.declinationSummerSolstice; // Correctly pull from Script A's specific variable
            const declinationDegWSR = window.declinationWinterSolstice; // Get Winter Solstice Declination

            if (isNaN(declinationDegSSR)) {
                console.error("ERROR: Declination value for SSR (window.declinationSummerSolstice) is not a valid number. Please ensure Script A correctly sets window.declinationSummerSolstice.");
                window.displayMessage('overallStatus', 'Error: SSR Declination data missing or invalid. Check Script A.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }
            if (isNaN(declinationDegWSR)) {
                console.error("ERROR: Declination value for WSR (window.declinationWinterSolstice) is not a valid number. Please ensure Script A correctly sets window.declinationWinterSolstice.");
                window.displayMessage('overallStatus', 'Error: WSR Declination data missing or invalid. Check Script A.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }
            // console.log(`SSR Declination used: ${declinationDegSSR}°`); // Removed verbose log
            // console.log(`WSR Declination used: ${declinationDegWSR}°`); // Removed verbose log


            // --- Process Orthodrome Intersection for SSR ---
            const ssrIntersectionPoint = await processOrthodromeIntersection(ssrZeroHorizonAzimuth, locationData, viewshedPolyline, "SSR", "SSR Orthodrome Intersection");
            let baseAzimuthForPolygonSSR = ssrZeroHorizonAzimuth;
            if (ssrIntersectionPoint && !isNaN(ssrIntersectionPoint.azimuth)) {
                baseAzimuthForPolygonSSR = ssrIntersectionPoint.azimuth;
                // console.log(`Using Turf intersection azimuth (${baseAzimuthForPolygonSSR.toFixed(3)}°) as base for SSR polygon.`); // Removed verbose log
            } else {
                // console.log(`Using original 0-horizon azimuth (${ssrZeroHorizonAzimuth.toFixed(3)}°) as base for SSR polygon (no valid SSR intersection).`); // Removed verbose log
            }

            // --- Process Orthodrome Intersection for WSR ---
            const wsrIntersectionPoint = await processOrthodromeIntersection(wsrZeroHorizonAzimuth, locationData, viewshedPolyline, "WSR", "WSR Orthodrome Intersection");
            let baseAzimuthForPolygonWSR = wsrZeroHorizonAzimuth;
            if (wsrIntersectionPoint && !isNaN(wsrIntersectionPoint.azimuth)) {
                baseAzimuthForPolygonWSR = wsrIntersectionPoint.azimuth;
                // console.log(`Using Turf intersection azimuth (${baseAzimuthForPolygonWSR.toFixed(3)}°) as base for WSR polygon.`); // Removed verbose log
            } else {
                // console.log(`Using original 0-horizon azimuth (${wsrZeroHorizonAzimuth.toFixed(3)}°) as base for WSR polygon (no valid WSR intersection).`); // Removed verbose log
            }


            // --- Process Summer Solstice Rise (SSR) ---
            const isSunriseLikeSSR = (parseFloat(baseAzimuthForPolygonSSR) >= 0 && parseFloat(baseAzimuthForPolygonSSR) <= 180);
            var ssrResult = await createAndAddPolygonLayer(
                baseAzimuthForPolygonSSR, // Use the new base azimuth as initial guess for time-based search
                window.normalizeAzimuth(baseAzimuthForPolygonSSR + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)), // Conceptual guess for search
                window.normalizeAzimuth(baseAzimuthForPolygonSSR + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)), // Conceptual guess for search
                horizonData, locationData, POLYGON_COLORS[0], "SSR", "Summer Solstice Rise",
                isSunriseLikeSSR, declinationDegSSR, locationData.elevation_amsl // Pass observer elevation
            );
            if (!ssrResult.success) anyCalculationFailed = true;

            // --- Process Winter Solstice Rise (WSR) ---
            const isSunriseLikeWSR = (parseFloat(baseAzimuthForPolygonWSR) >= 0 && parseFloat(baseAzimuthForPolygonWSR) <= 180);
            var wsrResult = await createAndAddPolygonLayer(
                baseAzimuthForPolygonWSR, // Use the WSR zero horizon azimuth as initial guess
                window.normalizeAzimuth(baseAzimuthForPolygonWSR + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)), // Conceptual guess for search
                window.normalizeAzimuth(baseAzimuthForPolygonWSR + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)), // Conceptual guess for search
                horizonData, locationData, POLYGON_COLORS[0], "WSR", "Winter Solstice Rise", // Use POLYGON_COLORS[0] (orange) for all solstices
                isSunriseLikeWSR, declinationDegWSR, locationData.elevation_amsl // Pass observer elevation
            );
            if (!wsrResult.success) anyCalculationFailed = true;


            // Adjust map bounds to encompass all drawn elements
            let bounds = new L.LatLngBounds();
            window.scriptCOverlayGroups.forEach(layerGroup => { // Use window.scriptCOverlayGroups
                if (window.map.hasLayer(layerGroup)) {
                    layerGroup.eachLayer(function(subLayer) {
                        if (subLayer.getLatLngs) { // For polygons/polylines
                            bounds.extend(subLayer.getBounds());
                        } else if (subLayer.getLatLng) { // For markers
                            bounds.extend(subLayer.getLatLng());
                        }
                    });
                }
            });

            // Also include the observer marker in the bounds
            if (observerMarker && observerMarker.getLatLng()) {
                bounds.extend(observerMarker.getLatLng());
            }

            if (bounds.isValid()) {
                window.map.fitBounds(bounds, { padding: [50, 50] });
            }

            if (!anyCalculationFailed) {
                window.displayMessage('overallStatus', 'Calculation Complete for all scenarios.', 'success');
            } else {
                window.displayMessage('overallStatus', 'Calculation finished with some scenarios not finding a direct match. Check detailed statuses and console for more info.', 'warn');
            }
            if (loadingSpinner) loadingSpinner.classList.add('hidden');
        });

        // --- GeoJSON Export Functionality (Removed from here, will be in separate script) ---
        // --- GeoJSON Import Functionality (Removed from here, will in separate script) ---
    });

})();