// Start Main IIFE to encapsulate the entire combined script and prevent global scope conflicts
(function() {
    // The top-level initialization guard (window.MaceHWTCalculatorInitialized) has been removed.
    // This ensures the script runs fully upon each execution/load, as per your instruction.

    const HWT_HORIZONE_SRC = "K52"; // Specific source ID from horiZONE.html example

    // --- Console Output Override ---
    // Capture original console methods to allow direct console logging for debugging,
    // while also providing a global displayMessage function for UI updates.
    const originalConsole = {
        log: console.log,
        warn: console.warn,
        error: console.error
    };

    // Re-assign console.log/warn/error to use the global displayMessage if needed for consistency
    // Fully re-enable original console logging for direct calls for debugging.
    console.log = function(...args) {
        originalConsole.log(...args);
    };
    console.warn = function(...args) {
        originalConsole.warn(...args);
    };
    console.error = function(...args) {
        originalConsole.error(...args);
    };

    // Expose displayMessage and clearResultsDisplay globally for the new export/import script
    /**
     * Displays a message in a specified HTML element and logs it to the console.
     * @param {string} elementId - The ID of the HTML element to update.
     * @param {string} message - The message to display.
     * @param {string} [type='status'] - The type of message ('status', 'success', 'error', 'warn').
     */
    window.displayMessage = function(elementId, message, type = 'status') {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = message;
            element.className = `status-message ${type}-message`; // Apply Tailwind classes for styling
        }
        // Log to original console for debugging purposes, but only for explicit displayMessage calls
        originalConsole.log(`Display Message [${type}] for ${elementId || 'N/A'}: ${message}`);
    };


    // --- Leaflet Map and Layer Variables (now referencing global objects from Script B) ---
    // These variables will be assigned from window.map and window.layersControl
    // when the DOM is ready and Script B has initialized them.
    let map = null;
    let layersControl = null;
    let observerMarker = null; // This will now be Script B's own L.CircleMarker (window.bigMarker)

    // Array to hold all LayerGroups created by Script C for easy clearing and GeoJSON export
    // Expose scriptCOverlayGroups globally for the new export/import script
    window.scriptCOverlayGroups = [];

    /**
     * Clears all dynamically added overlay layers from the map that were generated by this script (Script C).
     * This function now specifically targets layer groups managed by Script C.
     * Exposed globally for external access (e.g., from a clear button).
     */
    window.clearResultsDisplay = function() { // Made global
        // Iterate over layer groups created by window.scriptCOverlayGroups and remove them
        window.scriptCOverlayGroups.forEach(layerGroup => {
            if (window.map && window.map.hasLayer(layerGroup)) {
                window.map.removeLayer(layerGroup);
            }
            // Remove from layers control if it was added there
            if (window.layersControl && layerGroup.layerNameForControl) {
                window.layersControl.removeLayer(layerGroup);
            }
        });
        // Clear the array of Script C's layer groups
        window.scriptCOverlayGroups = [];
        console.log("All Script C overlay layers cleared from map and layers control.");
    };

    // --- Astronomical Constants ---
    // These are standard apparent altitudes of the SUN'S CENTER relative to the GEOMETRIC HORIZON (0 degrees)
    // when different parts of the sun are at the horizon. They include average atmospheric refraction.
    const SOLAR_REFRACTION = 0.583; // Approx. refraction at horizon for Sun (degrees)
    const SOLAR_SEMIDIAMETER = 0.25; // Approx. semi-diameter of the Sun (degrees)

    const EARTH_RADIUS_METERS = 6371000; // Earth's mean radius in meters (Still needed for other geodesic calcs if any)

    // Exact azimuthal shift based on user's guidance for 1 degree for full disk (0.51 per semi-diameter)
    // This value is used to calculate the initial azimuth guesses for the center and lower limb,
    // reflecting the horizontal spread of the sun's disk at a geometric horizon.
    const AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT = 0.51; // degrees of azimuth for one solar semi-diameter's worth of altitude change

    // Array of colors for future polygons (retained as per instruction)
    const POLYGON_COLORS = ['#fdba74', '#93c5fd', '#fca5a5', '#fcd34d', '#86efac']; // Tailwind colors: orange-300, blue-300, red-300, yellow-300, green-300

    /**
     * Converts degrees to radians.
     * @param {number} deg - Degrees.
     * @returns {number} Radians.
     */
    function toRadians(deg) {
        return deg * Math.PI / 180;
    }

    /**
     * Converts radians to degrees.
     * @param {number} rad - Radians.
     * @returns {number} Degrees.
     */
    function toDegrees(rad) {
        return rad * 180 / Math.PI;
    }

    /**
     * Normalizes an azimuth to be within the 0-360 degree range.
     * Exposed globally to resolve potential ReferenceError if used by other scripts.
     * @param {number} az - Azimuth in degrees.
     * @returns {number} Normalized azimuth in degrees (0-360).
     */
    window.normalizeAzimuth = function(az) {
        return (az % 360 + 360) % 360;
    };

    /**
     * Calculates the bearing from one LatLng point to another using LatLon library.
     * @param {L.LatLng} p1 - Start point (Leaflet LatLng object).
     * @param {L.LatLng} p2 - End point (Leaflet LatLng object).
     * @returns {number} Bearing in degrees (0-360), or NaN if LatLon library is not available.
     */
    function getBearingBetweenLatLngs(p1, p2) {
        if (typeof LatLon === 'undefined') {
            console.error("LatLon library not available for bearing calculation. Please ensure 'geodesy.js' is loaded.");
            return NaN;
        }
        // LatLon library expects (latitude, longitude)
        const ll1 = new LatLon(p1.lat, p1.lng);
        const ll2 = new LatLon(p2.lat, p2.lng);
        return ll1.bearingTo(ll2);
    }

    /**
     * Generates points for an orthodrome (great circle path) between a start point and an end point.
     * Overloaded to work from two points or from a start point, bearing, and distance.
     * Based on standard geodesic formulas (similar to Chris Veness's methods).
     * @param {number} lat1 - Start Latitude.
     * @param {number} lon1 - Start Longitude.
     * @param {number} lat2OrBearing - End Latitude OR Bearing in degrees.
     * @param {number} lon2OrDistanceKm - End Longitude OR Distance in kilometers.
     * @param {number} [numPoints=25] - Number of intermediate points to generate for smoothness.
     * @param {number} [bearing=undefined] - Bearing (if using start/bearing/distance overload).
     * @param {number} [distanceKm=undefined] - Distance (if using start/bearing/distance overload).
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for the orthodrome.
     */
    function generateOrthodromePoints(lat1, lon1, lat2OrBearing, lon2OrDistanceKm, numPoints = 25, bearing = undefined, distanceKm = undefined) {
        const points = [];
        points.push([lat1, lon1]);

        let endLat, endLon;
        let totalDistanceRad;

        const R = 6371; // Earth's radius in kilometers
        if (bearing !== undefined && distanceKm !== undefined) { // From start point, bearing, distance
            const brngRad = toRadians(bearing);
            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);

            totalDistanceRad = distanceKm / R;

            const latRad2 = Math.asin(Math.sin(latRad1) * Math.cos(totalDistanceRad) + Math.cos(latRad1) * Math.sin(totalDistanceRad) * Math.cos(brngRad));
            const lonRad2 = lonRad1 + Math.atan2(Math.sin(brngRad) * Math.sin(totalDistanceRad) * Math.cos(latRad1), Math.cos(totalDistanceRad) - Math.sin(latRad1) * Math.sin(latRad2));

            endLat = toDegrees(latRad2);
            endLon = toDegrees(lonRad2);
        } else { // From two points
            endLat = lat2OrBearing;
            endLon = lon2OrDistanceKm;

            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            const latRad2 = toRadians(endLat);
            const lonRad2 = toRadians(endLon);

            // Calculate angular distance for two points (Haversine-like for angular distance)
            const deltaLat = latRad2 - latRad1;
            const deltaLon = lonRad2 - lonRad1;
            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(latRad1) * Math.cos(latRad2) *
                Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
            totalDistanceRad = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        if (totalDistanceRad < 1e-6) { // Points are very close or identical
            points.push([endLat, endLon]);
            return points;
        }

        for (let i = 1; i < numPoints; i++) {
            const f = i / numPoints; // Fraction along the path
            const A = Math.sin((1 - f) * totalDistanceRad) / Math.sin(totalDistanceRad);
            const B = Math.sin(f * totalDistanceRad) / Math.sin(totalDistanceRad);

            // Spherical interpolation for intermediate points
            const x = A * Math.cos(toRadians(lat1)) * Math.cos(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.cos(toRadians(endLon));
            const y = A * Math.cos(toRadians(lat1)) * Math.sin(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.sin(toRadians(endLon));
            const z = A * Math.sin(toRadians(lat1)) + B * Math.sin(toRadians(endLat));

            const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
            const lon = Math.atan2(y, x);

            points.push([toDegrees(lat), toDegrees(lon)]);
        }
        points.push([endLat, endLon]); // Ensure the exact endpoint is included
        return points;
    }

    /**
     * Interpolates horizon Lat/Lon for a given azimuth.
     * Finds the two horizon data points that bracket the target azimuth and performs linear interpolation.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {{lat: number, lon: number, azimuth: number}|null} Interpolated lat/lon with original azimuth, or null if cannot interpolate.
     */
    function getInterpolatedHorizonLatLon(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = window.normalizeAzimuth(azimuth);
        let p1 = null;
        let p2 = null;

        // To handle wrap-around, create an extended version of horizonData
        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }
        // Ensure extended data is sorted by azimuth
        extendedHorizonData.sort((a, b) => a.azimuth - b.azimuth);

        // Find the two horizon data points that bracket the target azimuth
        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            // Adjust p2_az_for_interp if it's a wrap-around to ensure correct ratio calculation
            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            // Adjust targetAz_for_ratio if it's a wrap-around to fit within the p1_az_for_interp to p2_az_for_interp range
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            // --- Robustness: Check for problematic interpolation conditions or NaN values in source points ---
            const isAzimuthDifferenceZero = (p2_az_for_interp === p1_az_for_interp);
            const isP1Invalid = isNaN(p1.horizonLat) || isNaN(p1.horizonLon);
            const isP2Invalid = isNaN(p2.horizonLat) || isNaN(p2.horizonLon);

            if (isAzimuthDifferenceZero || isP1Invalid || isP2Invalid) {
                // Fallback to nearest neighbor if linear interpolation is problematic or data is invalid
                const distToP1 = Math.abs(targetAzimuthNormalized - p1_az_for_interp);
                const distToP2 = Math.abs(targetAzimuthNormalized - p2_az_for_interp);

                let chosenPoint = null;
                if (!isP1Invalid && !isP2Invalid) {
                    // Both are valid, pick the closer one
                    chosenPoint = (distToP1 <= distToP2) ? p1 : p2;
                } else if (!isP1Invalid) {
                    chosenPoint = p1; // Only p1 is valid
                } else if (!isP2Invalid) {
                    chosenPoint = p2; // Only p2 is valid
                }

                if (chosenPoint) {
                    console.warn(`getInterpolatedHorizonLatLon: Linear interpolation problematic (azimuth diff zero or NaN in source). Falling back to nearest neighbor (Azimuth: ${chosenPoint.azimuth.toFixed(3)}°).`);
                    return { lat: chosenPoint.horizonLat, lon: chosenPoint.horizonLon, azimuth: azimuth };
                } else {
                    console.error(`getInterpolatedHorizonLatLon: Cannot interpolate or find nearest valid point for azimuth ${azimuth.toFixed(3)}°. Both source points invalid.`);
                    return null; // Both source points are invalid
                }
            }
            // --- End Robustness ---

            const ratio = (targetAz_for_ratio - p1_az_for_interp) / (p2_az_for_interp - p1_az_for_interp);

            const interpolatedLat = p1.horizonLat + ratio * (p2.horizonLat - p1.horizonLat);
            const interpolatedLon = p1.horizonLon + ratio * (p2.horizonLon - p1.horizonLon);

            return { lat: interpolatedLat, lon: interpolatedLon, azimuth: azimuth };
        }
        return null;
    }

    /**
     * Interpolates and returns the altitude of the horizon for a given azimuth.
     * This function is crucial for the iterative search logic.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {number|null} The interpolated altitude, or null if cannot interpolate.
     */
    function getInterpolatedHorizonAltitude(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = window.normalizeAzimuth(azimuth);
        let p1 = null;
        let p2 = null;

        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }
        // Ensure extended data is sorted by azimuth
        extendedHorizonData.sort((a, b) => a.azimuth - b.azimuth);


        // Find the two horizon data points that bracket the target azimuth
        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            // --- Robustness: Check for problematic interpolation conditions or NaN values in source points ---
            const isAzimuthDifferenceZero = (p2_az_for_interp === p1_az_for_interp);
            const isP1AltitudeInvalid = isNaN(p1.altitude);
            const isP2AltitudeInvalid = isNaN(p2.altitude);

            if (isAzimuthDifferenceZero || isP1AltitudeInvalid || isP2AltitudeInvalid) {
                // Fallback to nearest neighbor if linear interpolation is problematic or data is invalid
                const distToP1 = Math.abs(targetAzimuthNormalized - p1_az_for_interp);
                const distToP2 = Math.abs(targetAzimuthNormalized - p2_az_for_interp);

                let chosenPoint = null;
                if (!isP1AltitudeInvalid && !isP2AltitudeInvalid) {
                    // Both are valid, pick the closer one
                    chosenPoint = (distToP1 <= distToP2) ? p1 : p2;
                } else if (!isP1AltitudeInvalid) {
                    chosenPoint = p1; // Only p1 is valid
                } else if (!isP2AltitudeInvalid) {
                    chosenPoint = p2; // Only p2 is valid
                }

                if (chosenPoint) {
                    console.warn(`getInterpolatedHorizonAltitude: Linear interpolation problematic (azimuth diff zero or NaN in source). Falling back to nearest neighbor (Azimuth: ${chosenPoint.azimuth.toFixed(3)}°).`);
                    return chosenPoint.altitude;
                } else {
                    console.error(`getInterpolatedHorizonAltitude: Cannot interpolate or find nearest valid point for azimuth ${azimuth.toFixed(3)}°. Both source points invalid.`);
                    return null; // Both source points are invalid
                }
            }
            // --- End Robustness ---

            const ratio = (targetAz_for_ratio - p1_az_for_interp) / (p2_az_for_interp - p1_az_for_interp);
            const interpolatedAltitude = p1.altitude + ratio * (p2.altitude - p1.altitude);
            return interpolatedAltitude;
        }
        return null;
    }

    /**
     * Collects horizon data points that lie azimuthally between two given azimuths,
     * always traversing in a *clockwise (increasing azimuth)* direction, handling 0/360 wrap-around.
     * The points are returned sorted by increasing azimuth.
     * @param {number} startAz - The starting azimuth of the segment (exclusive).
     * @param {number} endAz - The ending azimuth of the segment (exclusive).
     * @param {Array<Object>} horizonData - The full sorted horizon data.
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for points within the range, ordered by increasing azimuth.
     */
    function getIntermediateHorizonPoints(startAz, endAz, horizonData) {
        const points = [];
        if (!horizonData || horizonData.length === 0) {
            return points;
        }

        // Normalize start and end to be within 0-360 for initial range comparison
        const nStart = window.normalizeAzimuth(startAz);
        let nEnd = window.normalizeAzimuth(endAz);

        // If the intended clockwise range crosses 0/360 (e.g., from 350 to 10), adjust nEnd to be > nStart
        if (nStart > nEnd) {
            nEnd += 360;
        }

        // Create an extended version of horizonData with azimuths adjusted to cover the full 0-720 range
        // This simplifies range checking for wrapped segments.
        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        // Sort the extended data to ensure iteration is always in increasing azimuth order
        extendedHorizonData.sort((a, b) => a.azimuth - b.azimuth);

        // Iterate through the extended, sorted data
        for (const point of extendedHorizonData) {
            const currentAz = point.azimuth;

            // Include points strictly between start and end (exclusive of endpoints)
            // Use a small tolerance for floating-point comparisons
            if (currentAz > nStart + 0.0001 && currentAz < nEnd - 0.0001) {
                if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                    points.push([point.horizonLat, point.horizonLon]);
                }
            }
        }
        return points;
    }

    /**
     * Draws the viewshed horizon as a polyline using provided lat/lon values.
     * @param {Array<Object>} horizonData - Array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @returns {L.Polyline|null} The created Leaflet Polyline object, or null if invalid data.
     */
    function drawViewshedHorizonLine(horizonData) {
        if (!horizonData || horizonData.length === 0) {
            console.warn("No horizon data provided to draw viewshed polyline.");
            return null;
        }

        const polylinePoints = [];
        horizonData.forEach(point => {
            if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                polylinePoints.push([point.horizonLat, point.horizonLon]);
            } else {
                console.warn(`Skipping point (Azimuth: ${point.azimuth}) due to invalid horizonLat/Lon values. This point will not be part of the drawn viewshed polyline.`);
            }
        });

        if (polylinePoints.length >= 2) {
            // Close the polyline by adding the first point again at the end, if not already closed
            const firstPoint = polylinePoints[0];
            const lastPoint = polylinePoints[polylinePoints.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                polylinePoints.push(firstPoint);
            }
            console.log(`Viewshed terrain horizon polyline created with ${polylinePoints.length} points.`);
            return L.polyline(polylinePoints, {
                color: '#4299e1', // Blue color for the viewshed horizon line (Tailwind blue-500)
                weight: 2,
                opacity: 0.7,
                smoothFactor: 1
            });
        } else {
            console.warn("Not enough valid geographical horizon points to draw a polyline.");
            return null;
        }
    }

    /**
     * Draws an individual circle marker on the map for a calculated point.
     * @param {object} point - Object with lat, lon, azimuth properties.
     * @param {string} label - Label for the popup.
     * @param {string} color - The color for the marker (e.g., 'red', 'blue', 'orange').
     * @param {number} [radius=6] - Radius of the marker.
     * @param {number} [fillOpacity=0.0] - Fill opacity of the marker (default to 0 for outline only).
     * @returns {L.CircleMarker|null} The created Leaflet CircleMarker object, or null if invalid point data.
     */
    function drawIndividualPointMarker(point, label, color = '#fb923c', radius = 6, fillOpacity = 0.0) { // Default to Tailwind orange-400
        if (!map || !point || isNaN(point.lat) || isNaN(point.lon) || isNaN(point.azimuth)) {
            console.warn(`Cannot draw marker for "${label}": Invalid point data (Lat: ${point?.lat}, Lon: ${point?.lon}, Az: ${point?.azimuth}).`);
            return null;
        }

        const marker = L.circleMarker([point.lat, point.lon], {
            radius: radius,
            fillColor: color, // Use provided color
            color: color, // Use provided color for outline
            weight: 2,
            opacity: 1,
            fillOpacity: fillOpacity // Use provided fill opacity
        });
        marker.bindPopup(`<b>${label}</b><br>Azimuth: ${point.azimuth.toFixed(3)}°<br>Lat: ${point.lat.toFixed(6)}<br>Lon: ${point.lon.toFixed(6)}`);
        console.log(`Marker for ${label} created (not yet added to map directly).`);
        return marker;
    }

    /**
     * Prepares Leaflet LatLngs for Turf.js by converting to [lng, lat] format.
     * This function performs NO filtering, as per user's strict instruction.
     * Also logs the resulting array to the console.
     * @param {Array<L.LatLng|Array<L.LatLng>>} leafletLatLngs - Array of Leaflet LatLng objects, potentially nested.
     * @param {string} label - A label for console output (e.g., "Orthodrome", "Viewshed").
     * @returns {Array<Array<number>>} An array of [longitude, latitude] pairs, suitable for Turf.js.
     */
    function getTurfCoordinates(leafletLatLngs, label) {
        const turfCoords = [];
        // Determine if the input is a nested array (e.g., from L.geodesic.getLatLngs() which can return [[LatLng, ...]])
        const actualLatLngs = (leafletLatLngs.length === 1 && Array.isArray(leafletLatLngs[0]) && typeof leafletLatLngs[0][0] === 'object' && 'lat' in leafletLatLngs[0][0]) ? leafletLatLngs[0] : leafletLatLngs;

        for (let i = 0; i < actualLatLngs.length; i++) {
            const ll = actualLatLngs[i];
            // Directly grab lat and lng. If they are undefined, they will remain undefined.
            const lng = ll ? ll.lng : undefined;
            const lat = ll ? ll.lat : undefined;
            turfCoords.push([lng, lat]);
        }
        return turfCoords;
    }

    /**
     * Rewritten function: Reformats raw Leaflet LatLng objects (potentially nested array of objects)
     * into an array of [longitude, latitude] pairs for Turf.js.
     * This function performs NO filtering, as per user's strict instruction, and uses direct property access.
     * It logs the reformatted array to the console.
     * @param {Array<any>} rawDataArray - The raw data array, expected to contain LatLng objects, potentially nested.
     * @param {string} label - A label for console output.
     * @returns {Array<Array<number>>} The reformatted array of [longitude, latitude] pairs.
     */
    function reformatAndLogRawLatLngsForTurf(rawDataArray, label) {
        const reformattedCoords = [];

        // Check if the rawDataArray is a single array containing LatLng objects, or a nested array.
        // L.geodesic.getLatLngs() can return an array of arrays if it's a multi-part line.
        // For simplicity, we assume it's either a flat array of LatLngs or a single nested array of LatLngs.
        const actualLatLngObjects = (rawDataArray.length === 1 && Array.isArray(rawDataArray[0]) && typeof rawDataArray[0][0] === 'object' && 'lat' in rawDataArray[0][0]) ? rawDataArray[0] : rawDataArray;

        for (let i = 0; i < actualLatLngObjects.length; i++) {
            const ll = actualLatLngObjects[i]; // This is an individual LatLng object

            // Directly grab lat and lng properties. If ll is null/undefined or its properties are,
            // they will remain undefined, as per "no filtering".
            const lng = ll ? ll.lng : undefined;
            const lat = ll ? ll.lat : undefined;

            reformattedCoords.push([lng, lat]);
        }
        return reformattedCoords;
    }

    /**
     * Calculates the Sun's celestial altitude and azimuth for a given observer location, declination, and hour angle.
     * Formulas based on spherical astronomy.
     * @param {number} observerLatDeg - Observer's Latitude in Degrees.
     * @param {number} declinationDeg - Sun's Declination in Degrees.
     * @param {number} hourAngleDeg - Hour Angle in Degrees (0 at local meridian, increases westward).
     * @returns {{altitude: number, azimuth: number}|null} Object with altitude and azimuth in degrees, or null if invalid input.
     */
    function calculateSunPosition(observerLatDeg, declinationDeg, hourAngleDeg) {
        if (isNaN(observerLatDeg) || isNaN(declinationDeg) || isNaN(hourAngleDeg)) {
            console.error("Invalid input to calculateSunPosition: NaN detected. Inputs: Lat:", observerLatDeg, "Dec:", declinationDeg, "HA:", hourAngleDeg);
            return null;
        }

        const latRad = toRadians(observerLatDeg);
        const decRad = toRadians(declinationDeg);
        const haRad = toRadians(hourAngleDeg);

        // Calculate Altitude (h)
        // sin(h) = sin(dec)sin(lat) + cos(dec)cos(lat)cos(HA)
        let sinAltitude = Math.sin(decRad) * Math.sin(latRad) +
            Math.cos(decRad) * Math.cos(latRad) * Math.cos(haRad);

        // --- Clamping sinAltitude to [-1, 1] to prevent NaN from Math.asin due to floating point errors ---
        sinAltitude = Math.max(-1, Math.min(1, sinAltitude));

        let altitudeRad = Math.asin(sinAltitude); // Altitude in radians

        // Calculate Azimuth (A)
        // sin(A) = -sin(HA)cos(dec) / cos(h)
        // cos(A) = (sin(dec) - sin(h)sin(lat)) / (cos(h)cos(lat))
        // Use atan2 for correct quadrant
        const sinAz = -Math.sin(haRad) * Math.cos(decRad);
        const cosAz = Math.sin(decRad) * Math.cos(latRad) - Math.cos(decRad) * Math.sin(latRad) * Math.cos(haRad);

        let azimuthRad = Math.atan2(sinAz, cosAz);

        // If azimuth is NaN (e.g., due to sinAz and cosAz both being 0, which happens at zenith/nadir), handle it explicitly
        if (isNaN(azimuthRad)) {
            console.warn(`calculateSunPosition: Azimuth calculation resulted in NaN (sinAz: ${sinAz}, cosAz: ${cosAz}). Returning NaN for azimuth.`);
            return {
                altitude: toDegrees(altitudeRad),
                azimuth: NaN // Return NaN for azimuth, but don't return null for the whole object
            };
        }

        azimuthRad = (azimuthRad + 2 * Math.PI) % (2 * Math.PI); // Normalize to 0 to 2PI (from North, clockwise)

        const result = {
            altitude: toDegrees(altitudeRad),
            azimuth: toDegrees(azimuthRad)
        };

        return result;
    }


    /**
     * Finds the true rise/set azimuth by locating the point on the viewshed horizon
     * whose apparent altitude matches the celestial body's target apparent altitude.
     * This function now uses a robust bracketing and bisection search.
     * Exposed globally to resolve potential ReferenceError.
     * @param {Array<Object>} horizonData - An array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @param {string} targetLimb - 'UL', 'Center', or 'LL' to specify which part of the Sun.
     * @param {string} scenarioName - A descriptive name for the current calculation scenario (e.g., "Upper Limb").
     * @param {number} observerLat - The observer's latitude.
     * @param {number} observerLon - The observer's longitude.
     * @param {boolean} isSunriseLike - True if it's a sunrise-like event (azimuth increasing), false for sunset-like (azimuth decreasing).
     * @param {number} declinationDeg - The Sun's declination in degrees.
     * @param {number} observerElevationMeters - The observer's elevation above sea level in meters (currently not used for horizon adjustment per instructions).
     * @returns {{azimuth: number|null, lat: number|null, lon: number: number|null, hourAngle: number}|null} The calculated azimuth, Lat/Lon, and hour angle, or null if no matching point found.
     */
    window.findActualAzimuthForTargetApparentAltitude = async function( // Exposed globally
        horizonData,
        targetLimb, // 'UL', 'Center', 'LL'
        scenarioName,
        observerLat,
        observerLon,
        isSunriseLike,
        declinationDeg, // New: Declination in degrees
        observerElevationMeters // Observer's elevation in meters (not used for horizon adjustment)
    ) {
        const TOLERANCE_ALTITUDE = 0.001; // degrees, for matching altitude
        const HA_SEARCH_RESOLUTION = 0.1; // degrees, for initial bracketing search
        const HA_SEARCH_RANGE_DEGREES = 360; // Search across a full 360 degrees of HA (e.g., -180 to +180)
        const MAX_BISECTION_ITERATIONS = 100; // Max iterations for bisection method

        function setScenarioStatus(message, type = 'status') {
            console.log(`Display Message [${type}]: ${message}`);
        }
        setScenarioStatus(`Calculating ${scenarioName}...`, 'status');
        console.log(`--- ${scenarioName} Details ---`);
        console.log(`Target Limb: ${targetLimb}`);
        console.log(`Observer Lat: ${observerLat.toFixed(6)}, Lon: ${observerLon.toFixed(6)}, Elev: ${observerElevationMeters.toFixed(2)}m`);
        console.log(`Is Sunrise Like: ${isSunriseLike}, Declination: ${declinationDeg.toFixed(3)}°`);


        if (isNaN(declinationDeg)) {
            console.error(`ERROR: Invalid input for ${scenarioName}: declination is NaN.`);
            setScenarioStatus(`${scenarioName}: Error: Invalid declination.`, 'error');
            return null;
        }

        if (!horizonData || horizonData.length === 0) {
            console.error(`findActualAzimuthForTargetApparentAltitude (${scenarioName}): Empty horizonData received.`);
            setScenarioStatus(`${scenarioName}: Error: Empty horizon data.`, 'error');
            return null;
        }

        let bestBracket = null; // [lowHA, highHA]
        let minHaDiff = Infinity; // To find the earliest (for rise) or latest (for set) crossing

        console.log(`--- Bracketing Search for ${scenarioName} ---`);

        // Iterate across the full 360 degrees of hour angle to find a crossing
        for (let ha = -180; ha <= 180; ha += HA_SEARCH_RESOLUTION) {
            const sunPos = calculateSunPosition(observerLat, declinationDeg, ha);
            if (!sunPos || isNaN(sunPos.azimuth)) {
                console.log(`  HA: ${ha.toFixed(3)}°, SunPos invalid. Skipping.`); // Debug log
                continue;
            }

            // Calculate the Sun's apparent center altitude
            const sunApparentCenterAltitude = sunPos.altitude + SOLAR_REFRACTION;

            let terrainAltitude = getInterpolatedHorizonAltitude(sunPos.azimuth, horizonData);
            let terrainAzimuth = sunPos.azimuth; // Terrain Azimuth is the same as sun's azimuth for interpolation
            if (terrainAltitude === null) {
                console.log(`  HA: ${ha.toFixed(3)}°, SunAz: ${sunPos.azimuth.toFixed(3)}°, TerrainAlt: null. Skipping.`); // Debug log
                continue;
            }

            let limbAdjustmentValue = 0;
            if (targetLimb === 'UL') {
                // For Upper Limb at horizon, the center must be BELOW the terrain horizon.
                // So, the difference (Sun_Center - Terrain) needs to be positive by SOLAR_SEMIDIAMETER to mean UL is at horizon.
                limbAdjustmentValue = SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                // For Lower Limb at horizon, the center must be ABOVE the terrain horizon.
                // So, the difference (Sun_Center - Terrain) needs to be negative by SOLAR_SEMIDIAMETER to mean LL is at horizon.
                limbAdjustmentValue = -SOLAR_SEMIDIAMETER;
            }
            // If targetLimb is 'Center', limbAdjustmentValue remains 0.


            // The difference we want to drive to zero is:
            // (Sun's actual apparent center altitude - Terrain's apparent altitude) + limbAdjustmentValue
            const currentDifference = (sunApparentCenterAltitude - terrainAltitude) + limbAdjustmentValue;
            const isSunAboveTerrain = currentDifference >= 0; // True if limb is at or above terrain

            // Debugging output for each step of the coarse search
            console.log(`  Coarse Search HA: ${ha.toFixed(3)}°, Sun Az: ${sunPos.azimuth.toFixed(3)}°, Sun Apparent Center Alt: ${sunApparentCenterAltitude.toFixed(3)}°, Terrain Az: ${terrainAzimuth.toFixed(3)}°, Terrain Alt: ${terrainAltitude.toFixed(3)}°, Limb Adj: ${limbAdjustmentValue.toFixed(3)}°, Calculated Diff: ${currentDifference.toFixed(3)}°, Above Terrain: ${isSunAboveTerrain}`);


            // To check for a sign change, we need a previous point.
            // We'll store the previous valid point's difference.
            if (ha === -180) { // Initialize for the very first step
                // No actual comparison can be made yet.
            } else {
                // Get the previous point's data (HA - HA_SEARCH_RESOLUTION)
                const prevHa = ha - HA_SEARCH_RESOLUTION;
                const prevSunPos = calculateSunPosition(observerLat, declinationDeg, prevHa);
                if (!prevSunPos || isNaN(prevSunPos.azimuth)) {
                    continue; // Skip if previous sun position is invalid
                }

                const prevSunApparentCenterAltitude = prevSunPos.altitude + SOLAR_REFRACTION;
                const prevTerrainAltitude = getInterpolatedHorizonAltitude(prevSunPos.azimuth, horizonData);
                if (prevTerrainAltitude === null) {
                    continue; // Skip if previous terrain altitude is invalid
                }
                const prevDifference = (prevSunApparentCenterAltitude - prevTerrainAltitude) + limbAdjustmentValue; // Use same limb adjustment as current
                const wasSunAboveTerrain = prevDifference >= 0;

                // Check for a sign change (crossing)
                // For sunrise: was below terrain (prevDiff < 0) AND now at/above terrain (currDiff >= 0)
                // For sunset: was at/above terrain (prevDiff > 0) AND now below terrain (currDiff <= 0)
                const hasCrossed = (prevDifference < 0 && currentDifference >= 0 && isSunriseLike) ||
                                   (prevDifference > 0 && currentDifference <= 0 && !isSunriseLike);

                if (hasCrossed) {
                    // We found a crossing bracket [prevHa, ha]
                    // For sunrise, we want the earliest one (smallest HA).
                    // For sunset, we want the latest one (largest HA).
                    if (isSunriseLike) {
                        // For rise, we want the earliest HA where it crosses (smallest HA)
                        // This is how we "look backward" to find the very first unblocked state.
                        if (ha < minHaDiff) { // If this is an earlier crossing than any found so far
                            minHaDiff = ha;
                            bestBracket = [prevHa, ha];
                            console.log(`  Found potential rise bracket (earliest so far): [${prevHa.toFixed(3)}°, ${ha.toFixed(3)}°]`);
                        }
                    } else { // Sunset-like
                        // For set, we want the latest HA where it crosses (largest HA)
                        if (ha > minHaDiff || minHaDiff === Infinity) { // Update if larger, or if it's the first one found
                            minHaDiff = ha;
                            bestBracket = [prevHa, ha];
                            console.log(`  Found potential set bracket (latest so far): [${prevHa.toFixed(3)}°, ${ha.toFixed(3)}°]`);
                        }
                    }
                }
            }
        }

        if (!bestBracket) {
            console.error(`Bracketing Search for ${scenarioName}: No crossing bracket found in the full HA range.`);
            // Check if it's always blocked or always clear
            const testHA = isSunriseLike ? -90 : 90; // Test HA in appropriate quadrant
            const testSunPos = calculateSunPosition(observerLat, declinationDeg, testHA);
            if (!testSunPos || isNaN(testSunPos.azimuth)) {
                setScenarioStatus(`${scenarioName}: Failed initial sun position check.`, 'error');
                return null;
            }

            const testSunApparentCenterAltitude = testSunPos.altitude + SOLAR_REFRACTION; // Apply refraction for this test
            let testLimbAdjustmentValue = 0;
            if (targetLimb === 'UL') {
                testLimbAdjustmentValue = SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                testLimbAdjustmentValue = -SOLAR_SEMIDIAMETER;
            }
            const testTerrainAlt = getInterpolatedHorizonAltitude(testSunPos.azimuth, horizonData);

            if (testTerrainAlt !== null) {
                const testDifference = (testSunApparentCenterAltitude - testTerrainAlt) + testLimbAdjustmentValue;
                if (isSunriseLike && testDifference < -TOLERANCE_ALTITUDE) { // Sun is clearly below terrain
                    setScenarioStatus(`${scenarioName}: Object appears to be always BLOCKED by terrain. No rise event detected.`, 'error');
                } else if (!isSunriseLike && testDifference > TOLERANCE_ALTITUDE) { // Sun is clearly above terrain
                    setScenarioStatus(`${scenarioName}: Object appears to be always CLEAR of terrain. No set event detected.`, 'warn');
                } else {
                    setScenarioStatus(`${scenarioName}: No clear crossing detected in search range.`, 'warn');
                }
            } else {
                setScenarioStatus(`${scenarioName}: Could not interpolate terrain altitude for state check.`, 'error');
            }
            return null;
        }

        console.log(`Bracketing Search for ${scenarioName}: Best bracket found: [${bestBracket[0].toFixed(3)}°, ${bestBracket[1].toFixed(3)}°]`);

        // --- Step 2: Perform fine-grained bisection search within the bestBracket ---
        let lowHA = bestBracket[0];
        let highHA = bestBracket[1];
        let finalHA = null;

        for (let i = 0; i < MAX_BISECTION_ITERATIONS; i++) {
            const midHA = (lowHA + highHA) / 2;
            const midSunPos = calculateSunPosition(observerLat, declinationDeg, midHA);

            if (!midSunPos || isNaN(midSunPos.azimuth)) {
                console.warn(`${scenarioName}: Bisection search failed to calculate sun position (azimuth is NaN) at ${midHA.toFixed(3)}°. Breaking.`);
                break;
            }

            const midSunApparentCenterAltitude = midSunPos.altitude + SOLAR_REFRACTION;

            let midTerrainAlt = getInterpolatedHorizonAltitude(midSunPos.azimuth, horizonData);
            let midTerrainAzimuth = midSunPos.azimuth; // Terrain Azimuth is the same as sun's azimuth for interpolation
            if (midTerrainAlt === null) {
                console.warn(`${scenarioName}: Bisection search failed to interpolate terrain at ${midSunPos.azimuth.toFixed(3)}°. Breaking.`);
                break;
            }

            let limbAdjustmentValue = 0;
            if (targetLimb === 'UL') {
                limbAdjustmentValue = SOLAR_SEMIDIAMETER;
            } else if (targetLimb === 'LL') {
                limbAdjustmentValue = -SOLAR_SEMIDIAMETER;
            }

            const currentDifference = (midSunApparentCenterAltitude - midTerrainAlt) + limbAdjustmentValue;

            // Debugging output for each step of the bisection search
            console.log(`  Bisection Step ${i}: HA: ${midHA.toFixed(3)}°, Sun Az: ${midSunPos.azimuth.toFixed(3)}°, Sun Apparent Center Alt: ${midSunApparentCenterAltitude.toFixed(3)}°, Terrain Az: ${midTerrainAzimuth.toFixed(3)}°, Terrain Alt: ${midTerrainAlt.toFixed(3)}°, Limb Adj: ${limbAdjustmentValue.toFixed(3)}°, Calculated Diff: ${currentDifference.toFixed(3)}°`);


            if (Math.abs(currentDifference) < TOLERANCE_ALTITUDE) {
                finalHA = midHA;
                break; // Converged
            }

            if (isSunriseLike) {
                if (currentDifference < 0) { // Sun's limb is still below terrain, need to increase HA (move right on graph)
                    lowHA = midHA;
                } else { // Sun's limb is above terrain, need to decrease HA (move left on graph)
                    highHA = midHA;
                }
            } else { // Sunset-like
                if (currentDifference > 0) { // Sun's limb is still above terrain, need to increase HA (move right on graph)
                    lowHA = midHA;
                } else { // Sun's limb is below terrain, need to decrease HA (move left on graph)
                    highHA = midHA;
                }
            }
        }

        if (finalHA === null) {
            // If bisection didn't converge, use the midpoint of the final bracket
            finalHA = (lowHA + highHA) / 2;
            console.warn(`${scenarioName}: Bisection did not fully converge. Using midpoint of final bracket: ${finalHA.toFixed(3)}°.`);
        }

        const finalSunPos = calculateSunPosition(observerLat, declinationDeg, finalHA);
        if (finalSunPos && !isNaN(finalSunPos.azimuth)) {
            const finalPointLatLon = getInterpolatedHorizonLatLon(finalSunPos.azimuth, horizonData);
            if (finalPointLatLon && !isNaN(finalPointLatLon.lat) && !isNaN(finalPointLatLon.lon)) {
                setScenarioStatus(`${scenarioName}: Actual Azimuth calculated.`, 'success');
                console.log(`Calculated ${scenarioName} Result: Azimuth: ${finalSunPos.azimuth.toFixed(3)}°, Lat: ${finalPointLatLon.lat.toFixed(6)}, Lon: ${finalPointLatLon.lon.toFixed(6)}, HA: ${finalHA.toFixed(3)}°`);
                return {
                    azimuth: finalSunPos.azimuth,
                    lat: finalPointLatLon.lat,
                    lon: finalPointLatLon.lon,
                    hourAngle: finalHA
                };
            } else {
                console.warn(`${scenarioName}: Could not interpolate final horizon Lat/Lon for calculated azimuth ${finalSunPos.azimuth.toFixed(3)}° (Lat/Lon might be NaN). Returning null.`);
                return null;
            }
        } else {
            console.warn(`${scenarioName}: Failed to calculate final sun position for hour angle ${finalHA.toFixed(3)}° (azimuth might be NaN). Returning null.`);
            return null;
        }
    };


    /**
     * Finds the intersection point on the viewshed horizon for a given orthodromic line using Turf.js.
     * @param {L.LatLng} observerLatLng - The observer's location.
     * @param {Array<Array<number>>} orthodromeCoordsTurf - Array of [longitude, latitude] for the orthodromic line.
     * @param {Array<Array<number>>} viewshedCoordsTurf - Array of [longitude, latitude] for the viewshed horizon.
     * @returns {{lat: number, lon: number, azimuth: number}|null} The intersection point, or null if not found.
     */
    function findOrthodromeViewshedIntersection(observerLatLng, orthodromeCoordsTurf, viewshedCoordsTurf) {
        if (typeof turf === 'undefined') {
            console.error("Turf.js library not loaded. Cannot perform line intersection.");
            return null;
        }

        // --- Filter out invalid coordinates before passing to turf.lineString ---
        const validOrthodromeCoords = orthodromeCoordsTurf.filter(coords =>
            typeof coords[0] === 'number' && !isNaN(coords[0]) &&
            typeof coords[1] === 'number' && !isNaN(coords[1])
        );
        const validViewshedCoords = viewshedCoordsTurf.filter(coords =>
            typeof coords[0] === 'number' && !isNaN(coords[0]) &&
            typeof coords[1] === 'number' && !isNaN(coords[1])
        );

        // Check if there are enough valid coordinates after filtering
        if (validOrthodromeCoords.length < 2 || validViewshedCoords.length < 2) {
            console.warn("Insufficient valid coordinates after filtering for Turf.js intersection. Skipping intersection.");
            return null;
        }

        // The coordinates are now guaranteed to be valid numbers for turf.lineString
        const turfOrthodrome = turf.lineString(validOrthodromeCoords);
        const turfViewshed = turf.lineString(validViewshedCoords);

        // Find intersections
        const intersections = turf.lineIntersect(turfOrthodrome, turfViewshed);

        if (intersections.features.length > 0) {
            // Pick the first intersection point (closest to the start of the orthodrome)
            const intersectionCoords = intersections.features[0].geometry.coordinates;

            const intersectionLat = intersectionCoords[1];
            const intersectionLon = intersectionCoords[0];

            const intersectionLatLng = L.latLng(intersectionLat, intersectionLon);

            const actualIntersectionAzimuth = getBearingBetweenLatLngs(observerLatLng, intersectionLatLng);

            return {
                lat: intersectionLat,
                lon: intersectionLon,
                azimuth: actualIntersectionAzimuth
            };
        }

        return null; // No intersection found
    }

    /**
     * Helper function to process orthodrome intersection for a given state.
     * It draws the orthodrome and its intersection with the viewshed horizon on the map.
     * @param {number} zeroHorizonAzimuth - The 0-horizon azimuth for this state (initial guess for orthodrome direction).
     * @param {object} locationData - Observer's location data ({latitude, longitude, elevation_amsl}).
     * @param {L.Polyline} viewshedPolyline - The viewshed polyline.
     * @param {string} scenarioName - Name of the scenario (e.g., "SSR").
     * @param {L.LayerGroup} globalZeroHorizonLayerGroup - The global layer group to add intersection markers to.
     * @returns {{azimuth: number, lat: number, lon: number}|null} The intersection point, or null.
     */
    async function processOrthodromeIntersection(zeroHorizonAzimuth, locationData, viewshedPolyline, scenarioName, globalZeroHorizonLayerGroup) {
        let orthodromeLatLngsForGeodesic = [];
        let intersectionPoint = null;

        if (!isNaN(zeroHorizonAzimuth) && locationData && typeof LatLon !== 'undefined' && typeof L.geodesic !== 'undefined') {
            const observerLat = locationData.latitude;
            const observerLon = locationData.longitude;
            const lineDistanceKm = 200; // Sufficient distance to cross most horizons

            const startPointLatLon = new LatLon(observerLat, observerLon);
            const endPointLatLon = startPointLatLon.destinationPoint(lineDistanceKm * 1000, zeroHorizonAzimuth);

            if (isNaN(endPointLatLon.lat) || isNaN(endPointLatLon.lon)) {
                console.warn(`Calculated orthodrome end point for ${scenarioName} is invalid (NaN).`);
                orthodromeLatLngsForGeodesic = [L.latLng(observerLat, observerLon), L.latLng(NaN, NaN)];
            } else {
                orthodromeLatLngsForGeodesic = [
                    L.latLng(observerLat, observerLon),
                    L.latLng(endPointLatLon.lat, endPointLatLon.lon)
                ];
            }

            // Create the orthodrome line but DO NOT add it to a layer group here
            let tempOrthodromeLine = L.geodesic(orthodromeLatLngsForGeodesic, {
                steps: 100,
                color: '#f97316', // Orange-500 for orthodrome line
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 5'
            });

            const reformattedOrthodromeCoords = reformatAndLogRawLatLngsForTurf(tempOrthodromeLine.getLatLngs(), `Geodesic Orthodrome Attempt for ${scenarioName}`);

            if (viewshedPolyline && typeof turf !== 'undefined') {
                const viewshedActualLatLngs = viewshedPolyline.getLatLngs();
                const filteredViewshedCoordsTurf = getTurfCoordinates(viewshedActualLatLngs, `Viewshed Horizon for ${scenarioName}`);
                const observerLatLng = L.latLng(locationData.latitude, locationData.longitude);

                intersectionPoint = findOrthodromeViewshedIntersection(observerLatLng, reformattedOrthodromeCoords, filteredViewshedCoordsTurf);

                if (intersectionPoint) {
                    let intersectionMarker = drawIndividualPointMarker(intersectionPoint, `${scenarioName} Orthodrome Intersection`, '#f97316', 5, 1); // Orange-500, filled
                    if (intersectionMarker) {
                        globalZeroHorizonLayerGroup.addLayer(intersectionMarker); // Add marker to the global group
                        console.log(`Intersection marker for ${scenarioName} added to '0 Horizon Intersections' layer group.`);
                    }
                } else {
                    console.warn(`No intersection found between ${scenarioName} Orthodrome and Viewshed Horizon, or data invalid.`);
                }
            } else {
                console.warn(`Cannot find intersection for ${scenarioName}: Viewshed Horizon line not available, or Turf.js not loaded.`);
            }
        } else {
            console.warn(`Cannot process Orthodrome data for ${scenarioName}: base azimuth or location data invalid, or LatLon/L.geodesic not available.`);
        }
        return intersectionPoint;
    }


    /**
     * Fetches location data (lat, lon, elev_amsl) for a specific ID from heywhatsthat.com's result.json.
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<{latitude: number, longitude: number, elevation_amsl: number}|null>} Parsed location info.
     */
    async function fetchLocationData(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/bin/result.json?id=${hwtId}`;

        window.displayMessage('locationStatus', `Fetching location data for ID: ${hwtId} from /bin/result.json...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const json = JSON.parse(text);

            const lat = parseFloat(json?.lat);
            const lon = parseFloat(json?.lon);
            const elev_amsl = parseFloat(json?.elev_amsl);

            if (!isNaN(lat) && !isNaN(lon) && !isNaN(elev_amsl)) {
                window.displayMessage('locationStatus', 'Location data fetched successfully.', 'success-message');
                return { latitude: lat, longitude: lon, elevation_amsl: elev_amsl };
            }
            throw new Error("Missing or invalid 'lat', 'lon', or 'elev_amsl' in JSON response.");

        } catch (error) {
            window.displayMessage('locationStatus', 'Error fetching location data.', 'error-message');
            window.displayMessage('locationError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching location data:", error);
            return null;
        }
    }

    /**
     * Fetches and parses viewshed data from heywhatsthat.com's horizon.csv API.
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<Array<Object>>} A promise resolving to an array of {azimuth, altitude, horizonLat?, horizonLon?} objects.
     */
    async function fetchHorizonDataHoriZONE(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/api/horizon.csv?id=${hwtId}&resolution=.125&src=${HWT_HORIZONE_SRC}&keep=1`;

        window.displayMessage('viewshedStatus', `Fetching viewshed data for ID: ${hwtId} from /api/horizon.csv (horiZONE method)...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const lines = text.trim().split('\n');
            const horizonData = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#') || line === '') continue;

                const parts = line.split(',').map(s => s.trim());
                // Expecting: "bin bottom",azimuth,altitude,"distance (m)",latitude,longitude,"elevation (m amsl)"
                if (parts.length >= 6) {
                    const azimuth = parseFloat(parts[0]); // Azimuth from "bin bottom"
                    const altitude = parseFloat(parts[2]); // Altitude from "altitude" column
                    const horizonLat = parseFloat(parts[4]); // Latitude is in parts[4]
                    const horizonLon = parseFloat(parts[5]); // Longitude is in parts[5]

                    if (!isNaN(azimuth) && !isNaN(altitude) && !isNaN(horizonLat) && !isNaN(horizonLon)) {
                        horizonData.push({ azimuth, altitude, horizonLat, horizonLon });
                    } else {
                        console.warn(`Skipping line ${i} due to invalid number parsing (az:${parts[0]}, alt:${parts[2]}, lat:${parts[4]}, lon:${parts[5]}): ${line}`);
                    }
                } else {
                    console.warn(`Skipping line ${i} due to insufficient columns (${parts.length} < 6): ${line}`);
                }
            }

            if (horizonData.length === 0) {
                throw new Error("No valid azimuth-altitude-lat-lon pairs parsed from horizon.csv. Response might be malformed or empty data.");
            }

            horizonData.sort((a, b) => a.azimuth - b.azimuth);
            window.displayMessage('viewshedStatus', 'Viewshed data fetched successfully.', 'success-message');
            return horizonData;

        } catch (error) {
            window.displayMessage('viewshedStatus', 'Error fetching viewshed data.', 'error-message');
            window.displayMessage('viewshedError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching viewshed data:", error);
            return null;
        }
    }

    /**
     * Deduplicates an array of horizon data objects based on unique latitude and longitude pairs.
     * It keeps the first occurrence of a unique lat/lon pair.
     *
     * @param {Array<Object>} horizonData - An array of objects, where each object is expected
     * to have 'horizonLat' and 'horizonLon' properties.
     * @returns {Array<Object>} A new array containing only unique horizon data points based on lat/lon.
     */
    function deduplicateHorizonData(horizonData) {
        if (!horizonData || !Array.isArray(horizonData) || horizonData.length === 0) {
            console.warn("deduplicateHorizonData: Input is not a valid array or is empty. Returning empty array.");
            return [];
        }

        const seenLocations = new Set(); // To store unique "lat,lon" strings
        const uniqueData = [];           // To store the deduplicated objects

        for (const point of horizonData) {
            // Ensure point and its properties exist and are numbers before processing
            if (point && typeof point.horizonLat === 'number' && !isNaN(point.horizonLat) &&
                typeof point.horizonLon === 'number' && !isNaN(point.horizonLon)) {

                // Create a unique string key for the latitude and longitude
                // Using a fixed number of decimal places for consistency and to avoid floating-point comparison issues
                const key = `${point.horizonLat.toFixed(6)},${point.horizonLon.toFixed(6)}`;

                if (!seenLocations.has(key)) {
                    seenLocations.add(key);
                    uniqueData.push(point);
                }
            } else {
                console.warn("deduplicateHorizonData: Skipping invalid point (missing/non-numeric lat/lon):", point);
            }
        }

        console.log(`Deduplication complete. Original size: ${horizonData.length}, Unique size: ${uniqueData.length}`);
        return uniqueData;
    }


    // --- Event Listener for Form Submission ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Assign global map and layersControl from Script B once DOM is ready
        map = window.map;
        layersControl = window.layersControl;
        observerMarker = window.bigMarker; // Script B's draggable marker

        const form = document.getElementById('azimuthForm');
        const hwtIdentifierInput = document.getElementById('hwtIdentifierInput');
        const loadingSpinner = document.getElementById('loadingSpinner');

        form.addEventListener('submit', async (e) => {
            e.preventDefault(); // Prevent default form submission behavior (page reload)

            window.clearResultsDisplay(); // Use global clearResultsDisplay
            window.displayMessage('overallStatus', 'Starting terrain-adjusted azimuth calculation...', 'status');
            if (loadingSpinner) loadingSpinner.classList.remove('hidden');

            const hwtId = hwtIdentifierInput.value.trim();

            if (!hwtId) {
                window.displayMessage('overallStatus', 'Error: Please enter a HeyWhatsThat Identifier.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return; // Exit early if hwtId is empty
            }

            let locationData = null;
            let horizonData = null;
            let anyCalculationFailed = false;

            // --- Fetch Location Data ---
            locationData = await fetchLocationData(hwtId);
            if (!locationData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch location data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // Update Script B's map and marker with fetched location data
            // This is for visual consistency, not for calculation input in Script C.
            if (map && observerMarker) {
                map.setView([locationData.latitude, locationData.longitude], map.getZoom());
                // observerMarker.setLatLng([locationData.latitude, locationData.longitude]); // This is now handled by our new marker
                document.getElementById('latbox').value = locationData.latitude.toFixed(6); // Format for display
                document.getElementById('lngbox').value = locationData.longitude.toFixed(6); // Format for display
                // observerMarker.bindPopup(`<b>Observer Location</b><br>Lat: ${locationData.latitude.toFixed(4)}, Lon: ${locationData.longitude.toFixed(4)}`).openPopup(); // Handled by our new marker
            } else {
                console.error("Leaflet map or observer marker not available from Script B. Ensure Script B is loaded and initializes 'window.map' and 'window.bigMarker'.");
                window.displayMessage('overallStatus', 'Error: Map components not ready. Ensure map script is loaded.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- Fetch Viewshed Data ---
            horizonData = await fetchHorizonDataHoriZONE(hwtId);
            if (!horizonData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch viewshed data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- Deduplicate horizon data ---
            horizonData = deduplicateHorizonData(horizonData);

            window.displayMessage('overallStatus', "Calculating actual azimuths...", 'status');

            // --- Viewshed Horizon Line ---
            const viewshedPolyline = drawViewshedHorizonLine(horizonData);
            if (viewshedPolyline) {
                let viewshedHorizonLineGroup = L.layerGroup();
                viewshedHorizonLineGroup.addLayer(viewshedPolyline);
                viewshedHorizonLineGroup.layerNameForControl = "Viewshed Horizon"; // Name for layers control
                window.map.addLayer(viewshedHorizonLineGroup);
                window.layersControl.addOverlay(viewshedHorizonLineGroup, viewshedHorizonLineGroup.layerNameForControl);
                window.scriptCOverlayGroups.push(viewshedHorizonLineGroup);
            } else {
                console.warn("Viewshed horizon polyline could not be drawn. Calculations might be affected.");
                window.displayMessage('viewshedStatus', 'Warning: Viewshed horizon line could not be drawn.', 'warn');
            }

            // --- Read Mapped Azimuth Values from Script A's Global Variables (All retained as per instruction) ---
            let wsrZeroHorizonAzimuth = window.solsticeaziwinrise;
            let wssZeroHorizonAzimuth = window.solsticeaziwinset;
            let ssrZeroHorizonAzimuth = window.solsticeazisumrise;
            let sssZeroHorizonAzimuth = window.solsticeazisumset;
            let ncqrZeroHorizonAzimuth = window.crossquarterazisumrise;
            let scqrZeroHorizonAzimuth = window.crossquarteraziwinrise;
            let ncqsZeroHorizonAzimuth = window.crossquarterazisumset;
            let scqsZeroHorizonAzimuth = window.crossquarteraziwinset;
            let nmlrZeroHorizonAzimuth = window.majorazisumrise;
            let nmlsZeroHorizonAzimuth = window.majorazisumset;
            let smlrZeroHorizonAzimuth = window.majoraziwinrise;
            let smnlsZeroHorizonAzimuth_major = window.majoraziwinset;
            let nmnlrZeroHorizonAzimuth = window.minorazisumrise;
            let smnlrZeroHorizonAzimuth = window.minorazisumrise;
            let nmnlsZeroHorizonAzimuth = window.minorazisumset;
            let smnlsZeroHorizonAzimuth_minor = window.minorazisumset; // Corrected from minoraziwinset
            let erZeroHorizonAzimuth = window.equinoxazisumrise;
            let esZeroHorizonAzimuth = window.equinoxazisumset;

            // --- Get Declination Values from Script A's global variables (All retained as per instruction) ---
            const declinationDegSSR = window.declinationSummerSolstice;
            const declinationDegWSR = window.declinationWinterSolstice;
            const declinationDegEquinox = window.declinationEquinox;
            const declinationDegCrossQuarter = window.declinationCrossQuarter;
            const declinationDegMajorLunar = window.declinationMajorLunar;
            const declinationDegMinorLunar = window.declinationMinorLunar;

            if (isNaN(declinationDegSSR)) {
                console.error("ERROR: Declination value for SSR (window.declinationSummerSolstice) is not a valid number. Please ensure Script A correctly sets window.declinationSummerSolstice.");
                window.displayMessage('overallStatus', 'Error: SSR Declination data missing or invalid. Check Script A.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }
            // Retain checks for other declinations even if not used in current calculation flow
            if (isNaN(declinationDegWSR)) { console.warn("Warning: WSR Declination value is NaN."); }
            if (isNaN(declinationDegEquinox)) { console.warn("Warning: Equinox Declination value is NaN."); }
            if (isNaN(declinationDegCrossQuarter)) { console.warn("Warning: Cross Quarter Declination value is NaN."); }
            if (isNaN(declinationDegMajorLunar)) { console.warn("Warning: Major Lunar Declination value is NaN."); }
            if (isNaN(declinationDegMinorLunar)) { console.warn("Warning: Minor Lunar Declination value is NaN."); }


            // --- Initialize a single layer group for all Solstice markers ---
            let solsticesLayerGroup = L.layerGroup();
            solsticesLayerGroup.layerNameForControl = "Solstices"; // Name for layers control
            window.map.addLayer(solsticesLayerGroup); // Add to map immediately for visibility
            window.layersControl.addOverlay(solsticesLayerGroup, solsticesLayerGroup.layerNameForControl);
            window.scriptCOverlayGroups.push(solsticesLayerGroup); // Add to Script C's managed layers


            // --- Initialize a single layer group for all 0 Horizon Intersections ---
            let zeroHorizonIntersectionsLayerGroup = L.layerGroup();
            zeroHorizonIntersectionsLayerGroup.layerNameForControl = "0 Horizon Intersections";
            window.map.addLayer(zeroHorizonIntersectionsLayerGroup); // Add to map immediately for visibility
            window.layersControl.addOverlay(zeroHorizonIntersectionsLayerGroup, zeroHorizonIntersectionsLayerGroup.layerNameForControl);
            window.scriptCOverlayGroups.push(zeroHorizonIntersectionsLayerGroup); // Add to Script C's managed layers

            // --- Add the Observer Location marker to '0 Horizon Intersections' layer group ---
            const observerLatLng = L.latLng(locationData.latitude, locationData.longitude);
            const observerPointForMarker = {
                lat: locationData.latitude,
                lon: locationData.longitude,
                azimuth: 0 // Azimuth not relevant for observer point, set to 0 or NaN if preferred
            };
            let observerLocationMarker = drawIndividualPointMarker(observerPointForMarker, "Observer Location", '#f97316', 5, 1); // Orange, radius 5, filled
            if (observerLocationMarker) {
                zeroHorizonIntersectionsLayerGroup.addLayer(observerLocationMarker);
                console.log("Observer Location marker added to '0 Horizon Intersections' layer group.");
            } else {
                console.error("Failed to draw Observer Location marker.");
            }


            // --- Process Orthodrome Intersection for SSR (Visual only, not for initial guess of UL) ---
            // This call remains to draw the orange line and its intersection with the viewshed based on the geometric horizon.
            const ssrIntersectionPoint = await processOrthodromeIntersection(ssrZeroHorizonAzimuth, locationData, viewshedPolyline, "SSR", zeroHorizonIntersectionsLayerGroup);

            // --- Process Summer Solstice Rise (SSR) Upper Limb ---
            // isSunriseLikeSSR is determined based on the geometric horizon azimuth, which is generally correct for rise/set direction.
            const isSunriseLikeSSR = (window.normalizeAzimuth(ssrZeroHorizonAzimuth) >= 0 && window.normalizeAzimuth(ssrZeroHorizonAzimuth) <= 180);

            const actualPointUL_SSR = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'UL', "SSR Upper Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeSSR, declinationDegSSR, locationData.elevation_amsl
            );

            if (actualPointUL_SSR) {
                let ulMarker = drawIndividualPointMarker(actualPointUL_SSR, "SSR Upper Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (ulMarker) {
                    solsticesLayerGroup.addLayer(ulMarker);
                    console.log("SSR Upper Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw SSR Upper Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("SSR Upper Limb calculation failed.");
            }

            // --- Process Summer Solstice Rise (SSR) Center ---
            const actualPointCenter_SSR = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'Center', "SSR Center at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeSSR, declinationDegSSR, locationData.elevation_amsl
            );

            if (actualPointCenter_SSR) {
                let centerMarker = drawIndividualPointMarker(actualPointCenter_SSR, "SSR Center", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (centerMarker) {
                    solsticesLayerGroup.addLayer(centerMarker);
                    console.log("SSR Center marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw SSR Center marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("SSR Center calculation failed.");
            }

            // --- Process Summer Solstice Rise (SSR) Lower Limb ---
            const actualPointLL_SSR = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'LL', "SSR Lower Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeSSR, declinationDegSSR, locationData.elevation_amsl
            );

            if (actualPointLL_SSR) {
                let llMarker = drawIndividualPointMarker(actualPointLL_SSR, "SSR Lower Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (llMarker) {
                    solsticesLayerGroup.addLayer(llMarker);
                    console.log("SSR Lower Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw SSR Lower Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("SSR Lower Limb calculation failed.");
            }


            // --- Process Orthodrome Intersection for WSR (Visual only) ---
            const wsrIntersectionPoint = await processOrthodromeIntersection(wsrZeroHorizonAzimuth, locationData, viewshedPolyline, "WSR", zeroHorizonIntersectionsLayerGroup);

            // --- Process Winter Solstice Rise (WSR) Upper Limb ---
            const isSunriseLikeWSR = (window.normalizeAzimuth(wsrZeroHorizonAzimuth) >= 0 && window.normalizeAzimuth(wsrZeroHorizonAzimuth) <= 180);
            const actualPointUL_WSR = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'UL', "WSR Upper Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeWSR, declinationDegWSR, locationData.elevation_amsl
            );

            if (actualPointUL_WSR) {
                let ulMarkerWSR = drawIndividualPointMarker(actualPointUL_WSR, "WSR Upper Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (ulMarkerWSR) {
                    solsticesLayerGroup.addLayer(ulMarkerWSR);
                    console.log("WSR Upper Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw WSR Upper Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("WSR Upper Limb calculation failed.");
            }

            // --- Process Winter Solstice Rise (WSR) Center ---
            const actualPointCenter_WSR = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'Center', "WSR Center at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeWSR, declinationDegWSR, locationData.elevation_amsl
            );

            if (actualPointCenter_WSR) {
                let centerMarkerWSR = drawIndividualPointMarker(actualPointCenter_WSR, "WSR Center", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (centerMarkerWSR) {
                    solsticesLayerGroup.addLayer(centerMarkerWSR);
                    console.log("WSR Center marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw WSR Center marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("WSR Center calculation failed.");
            }

            // --- Process Winter Solstice Rise (WSR) Lower Limb ---
            const actualPointLL_WSR = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'LL', "WSR Lower Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeWSR, declinationDegWSR, locationData.elevation_amsl
            );

            if (actualPointLL_WSR) {
                let llMarkerWSR = drawIndividualPointMarker(actualPointLL_WSR, "WSR Lower Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (llMarkerWSR) {
                    solsticesLayerGroup.addLayer(llMarkerWSR);
                    console.log("WSR Lower Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw WSR Lower Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("WSR Lower Limb calculation failed.");
            }

            // --- Process Orthodrome Intersection for SSS (Visual only) ---
            const sssIntersectionPoint = await processOrthodromeIntersection(sssZeroHorizonAzimuth, locationData, viewshedPolyline, "SSS", zeroHorizonIntersectionsLayerGroup);

            // --- Process Summer Solstice Set (SSS) Upper Limb ---
            // isSunriseLikeSSS is determined based on the geometric horizon azimuth, which is generally correct for rise/set direction.
            const isSunriseLikeSSS = (window.normalizeAzimuth(sssZeroHorizonAzimuth) >= 0 && window.normalizeAzimuth(sssZeroHorizonAzimuth) <= 180); // Should be false for set
            const actualPointUL_SSS = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'UL', "SSS Upper Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeSSS, declinationDegSSR, locationData.elevation_amsl
            );

            if (actualPointUL_SSS) {
                let ulMarkerSSS = drawIndividualPointMarker(actualPointUL_SSS, "SSS Upper Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (ulMarkerSSS) {
                    solsticesLayerGroup.addLayer(ulMarkerSSS);
                    console.log("SSS Upper Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw SSS Upper Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("SSS Upper Limb calculation failed.");
            }

            // --- Process Summer Solstice Set (SSS) Center ---
            const actualPointCenter_SSS = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'Center', "SSS Center at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeSSS, declinationDegSSR, locationData.elevation_amsl
            );

            if (actualPointCenter_SSS) {
                let centerMarkerSSS = drawIndividualPointMarker(actualPointCenter_SSS, "SSS Center", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (centerMarkerSSS) {
                    solsticesLayerGroup.addLayer(centerMarkerSSS);
                    console.log("SSS Center marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw SSS Center marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("SSS Center calculation failed.");
            }

            // --- Process Summer Solstice Set (SSS) Lower Limb ---
            const actualPointLL_SSS = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'LL', "SSS Lower Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeSSS, declinationDegSSR, locationData.elevation_amsl
            );

            if (actualPointLL_SSS) {
                let llMarkerSSS = drawIndividualPointMarker(actualPointLL_SSS, "SSS Lower Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (llMarkerSSS) {
                    solsticesLayerGroup.addLayer(llMarkerSSS);
                    console.log("SSS Lower Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw SSS Lower Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("SSS Lower Limb calculation failed.");
            }

            // --- Process Orthodrome Intersection for WSS (Visual only) ---
            const wssIntersectionPoint = await processOrthodromeIntersection(wssZeroHorizonAzimuth, locationData, viewshedPolyline, "WSS", zeroHorizonIntersectionsLayerGroup);

            // --- Process Winter Solstice Set (WSS) Upper Limb ---
            const isSunriseLikeWSS = (window.normalizeAzimuth(wssZeroHorizonAzimuth) >= 0 && window.normalizeAzimuth(wssZeroHorizonAzimuth) <= 180); // Should be false for set
            const actualPointUL_WSS = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'UL', "WSS Upper Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeWSS, declinationDegWSR, locationData.elevation_amsl
            );

            if (actualPointUL_WSS) {
                let ulMarkerWSS = drawIndividualPointMarker(actualPointUL_WSS, "WSS Upper Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (ulMarkerWSS) {
                    solsticesLayerGroup.addLayer(ulMarkerWSS);
                    console.log("WSS Upper Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw WSS Upper Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("WSS Upper Limb calculation failed.");
            }

            // --- Process Winter Solstice Set (WSS) Center ---
            const actualPointCenter_WSS = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'Center', "WSS Center at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeWSS, declinationDegWSR, locationData.elevation_amsl
            );

            if (actualPointCenter_WSS) {
                let centerMarkerWSS = drawIndividualPointMarker(actualPointCenter_WSS, "WSS Center", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (centerMarkerWSS) {
                    solsticesLayerGroup.addLayer(centerMarkerWSS);
                    console.log("WSS Center marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw WSS Center marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("WSS Center calculation failed.");
            }

            // --- Process Winter Solstice Set (WSS) Lower Limb ---
            const actualPointLL_WSS = await window.findActualAzimuthForTargetApparentAltitude(
                horizonData, 'LL', "WSS Lower Limb at Horizon", locationData.latitude, locationData.longitude, isSunriseLikeWSS, declinationDegWSR, locationData.elevation_amsl
            );

            if (actualPointLL_WSS) {
                let llMarkerWSS = drawIndividualPointMarker(actualPointLL_WSS, "WSS Lower Limb", POLYGON_COLORS[0], 5, 1); // Radius 5, Orange
                if (llMarkerWSS) {
                    solsticesLayerGroup.addLayer(llMarkerWSS);
                    console.log("WSS Lower Limb marker added to Solstices layer group.");
                } else {
                    anyCalculationFailed = true;
                    console.error("Failed to draw WSS Lower Limb marker.");
                }
            } else {
                anyCalculationFailed = true;
                console.error("WSS Lower Limb calculation failed.");
            }


            // Adjust map bounds to encompass all drawn elements
            let bounds = new L.LatLngBounds();
            window.scriptCOverlayGroups.forEach(layerGroup => {
                if (window.map.hasLayer(layerGroup)) {
                    layerGroup.eachLayer(function(subLayer) {
                        if (subLayer.getLatLngs) { // For polylines
                            try {
                                bounds.extend(subLayer.getBounds());
                            } catch (e) {
                                console.warn("Error getting bounds for subLayer (polyline), skipping:", e);
                            }
                        } else if (subLayer.getLatLng) { // For markers
                            try {
                                bounds.extend(subLayer.getLatLng());
                            } catch (e) {
                                console.warn("Error getting LatLng for subLayer (marker), skipping:", e);
                            }
                        }
                    });
                }
            });

            if (bounds.isValid()) {
                window.map.fitBounds(bounds, { padding: [50, 50] });
            } else {
                console.warn("Calculated bounds are invalid. Cannot fit map to bounds.");
            }

            if (!anyCalculationFailed) {
                window.displayMessage('overallStatus', 'All Solstice Rise & Set calculations complete.', 'success');
            } else {
                window.displayMessage('overallStatus', 'All Solstice Rise & Set calculations finished with issues. Check console for more info.', 'warn');
            }
            if (loadingSpinner) loadingSpinner.classList.add('hidden');
        });
    });

})();