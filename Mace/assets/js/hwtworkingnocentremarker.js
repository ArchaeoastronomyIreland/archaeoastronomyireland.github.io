// Start Main IIFE to encapsulate the entire combined script and prevent global scope conflicts
(function() {
    // The top-level initialization guard (window.MaceHWTCalculatorInitialized) has been removed.
    // This ensures the script runs fully upon each execution/load, as per your instruction.

    const HWT_HORIZONE_SRC = "K52"; // Specific source ID from horiZONE.html example

    // --- Console Output Override ---
    const originalConsole = { ...console };
    // Since the on-page console output div is removed, appendToConsole now just uses native console
    function appendToConsole(message, type = 'log') {
        originalConsole.log(...(Array.isArray(message) ? message : [message])); // Ensure it handles arrays or single messages
    }

    // Expose displayMessage and clearResultsDisplay globally for the new export/import script
    window.displayMessage = function(elementId, message, type = 'status') {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = message;
            element.className = `status-message ${type}-message`; // Apply Tailwind classes for styling
        }
    };
    // Re-assign console.log/warn/error to use the global displayMessage if needed for consistency
    console.log = function(...args) {
        originalConsole.log(...args);
        window.displayMessage(null, args.join(' '), 'log'); // Pass null for elementId if not targeting a specific div
    };
    console.warn = function(...args) {
        originalConsole.warn(...args);
        window.displayMessage(null, 'WARNING: ' + args.join(' '), 'warn');
    };
    console.error = function(...args) {
        originalConsole.error(...args);
        window.displayMessage(null, 'ERROR: ' + args.join(' '), 'error');
    };


    // --- Leaflet Map and Layer Variables (now referencing global objects from Script B) ---
    // These variables will be assigned from window.map and window.layersControl
    // when the DOM is ready and Script B has initialized them.
    let map = null;
    let layersControl = null;
    let observerMarker = null; // This will now be Script C's own L.CircleMarker

    // Array to hold all LayerGroups created by Script C for easy clearing and GeoJSON export
    // Expose scriptCOverlayGroups globally for the new export/import script
    window.scriptCOverlayGroups = [];

    /**
     * Clears all dynamically added overlay layers from the map that were generated by Script C.
     * This function now specifically targets layer groups managed by Script C.
     */
    window.clearResultsDisplay = function() { // Made global
        // Iterate over layer groups created by window.scriptCOverlayGroups and remove them
        window.scriptCOverlayGroups.forEach(layerGroup => {
            if (window.map && window.map.hasLayer(layerGroup)) {
                window.map.removeLayer(layerGroup);
            }
            // Remove from layers control if it was added there
            if (window.layersControl && layerGroup.layerNameForControl) {
                window.layersControl.removeLayer(layerGroup);
            }
        });
        // Clear the array of Script C's layer groups
        window.scriptCOverlayGroups = [];
    };

    // --- Astronomical Constants ---
    // These are standard apparent altitudes of the SUN'S CENTER relative to the GEOMETRIC HORIZON (0 degrees)
    // when different parts of the sun are at the horizon. They include average atmospheric refraction.
    const SOLAR_REFRACTION = 0.583; // Approx. refraction at horizon for Sun (degrees)
    const SOLAR_SEMIDIAMETER = 0.25; // Approx. semi-diameter of the Sun (degrees)

    // Target apparent altitude of the SUN'S CENTER for different events, relative to a geometric horizon (0 degrees)
    // These are the values that the 'horizonData[i].altitude' (which is also apparent altitude) needs to match.
    const TARGET_APPARENT_ALTITUDE_SUN_UPPER_LIMB_AT_HORIZON = -SOLAR_REFRACTION - SOLAR_SEMIDIAMETER; // Approx. -0.833 degrees (standard for official sunrise/sunset)
    const TARGET_APPARENT_ALTITUDE_SUN_CENTER_AT_HORIZON = -SOLAR_REFRACTION; // Approx. -0.583 degrees
    const TARGET_APPARENT_ALTITUDE_SUN_LOWER_LIMB_AT_HORIZON = -SOLAR_REFRACTION + SOLAR_SEMIDIAMETER; // Approx. -0.333 degrees

    // Exact azimuthal shift based on user's guidance for 1 degree for full disk (0.51 per semi-diameter)
    // This value is used to calculate the initial azimuth guesses for the center and lower limb,
    // reflecting the horizontal spread of the sun's disk at a geometric horizon.
    const AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT = 0.51; // degrees of azimuth for one solar semi-diameter's worth of altitude change

    // Array of colors for future polygons
    const POLYGON_COLORS = ['orange', 'blue', 'red', 'yellow', 'green'];

    /**
     * Generates points for an orthodrome (great circle path) between a start point and an end point.
     * Overloaded to work from two points or from a start point, bearing, and distance.
     * Based on standard geodesic formulas (similar to Chris Veness's methods).
     * @param {number} lat1 - Start Latitude.
     * @param {number} lon1 - Start Longitude.
     * @param {number} lat2OrBearing - End Latitude OR Bearing in degrees.
     * @param {number} lon2OrDistanceKm - End Longitude OR Distance in kilometers.
     * @param {number} [numPoints=25] - Number of intermediate points to generate for smoothness.
     * @param {number} [bearing=undefined] - Bearing (if using start/bearing/distance overload).
     * @param {number} [distanceKm=undefined] - Distance (if using start/bearing/distance overload).
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for the orthodrome.
     */
    function generateOrthodromePoints(lat1, lon1, lat2OrBearing, lon2OrDistanceKm, numPoints = 25, bearing = undefined, distanceKm = undefined) {
        const points = [];
        points.push([lat1, lon1]);

        let endLat, endLon;
        let totalDistanceRad;

        const R = 6371; // Earth's radius in kilometers
        if (bearing !== undefined && distanceKm !== undefined) { // From start point, bearing, distance
            const brngRad = toRadians(bearing);
            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            totalDistanceRad = distanceKm / R;

            const latRad2 = Math.asin(Math.sin(latRad1) * Math.cos(totalDistanceRad) + Math.cos(latRad1) * Math.sin(totalDistanceRad) * Math.cos(brngRad));
            const lonRad2 = lonRad1 + Math.atan2(Math.sin(brngRad) * Math.sin(totalDistanceRad) * Math.cos(latRad1), Math.cos(totalDistanceRad) - Math.sin(latRad1) * Math.sin(latRad2));

            endLat = toDegrees(latRad2);
            endLon = toDegrees(lonRad2);
        } else { // From two points
            endLat = lat2OrBearing;
            endLon = lon2OrDistanceKm;

            const latRad1 = toRadians(lat1);
            const lonRad1 = toRadians(lon1);
            const latRad2 = toRadians(endLat);
            const lonRad2 = toRadians(endLon);

            // Calculate angular distance for two points (Haversine-like for angular distance)
            const deltaLat = latRad2 - latRad1;
            const deltaLon = lonRad2 - lonRad1; // Corrected: was lon1
            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(latRad1) * Math.cos(latRad2) *
                Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
            totalDistanceRad = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        if (totalDistanceRad < 1e-6) { // Points are very close or identical
            points.push([endLat, endLon]);
            return points;
        }

        for (let i = 1; i < numPoints; i++) {
            const f = i / numPoints; // Fraction along the path
            const A = Math.sin((1 - f) * totalDistanceRad) / Math.sin(totalDistanceRad);
            const B = Math.sin(f * totalDistanceRad) / Math.sin(totalDistanceRad);

            const x = A * Math.cos(toRadians(lat1)) * Math.cos(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.cos(toRadians(endLon));
            const y = A * Math.cos(toRadians(lat1)) * Math.sin(toRadians(lon1)) + B * Math.cos(toRadians(endLat)) * Math.sin(toRadians(lon2OrDistanceKm));
            const z = A * Math.sin(toRadians(lat1)) + B * Math.sin(toRadians(endLat));

            const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
            const lon = Math.atan2(y, x);

            points.push([toDegrees(lat), toDegrees(lon)]);
        }
        points.push([endLat, endLon]); // Ensure the exact endpoint is included
        return points;
    }

    /**
     * Interpolates horizon Lat/Lon for a given azimuth.
     * Finds the two horizon data points that bracket the target azimuth and performs linear interpolation.
     * @param {number} azimuth - The azimuth to interpolate for (0-360 degrees).
     * @param {Array<Object>} horizonData - The full horizon data, expected to be sorted by azimuth.
     * @returns {{lat: number, lon: number, azimuth: number}|null} Interpolated lat/lon with original azimuth, or null if cannot interpolate.
     */
    function getInterpolatedHorizonLatLon(azimuth, horizonData) {
        if (!horizonData || horizonData.length === 0) {
            return null;
        }

        let targetAzimuthNormalized = normalizeAzimuth(azimuth);
        let p1 = null;
        let p2 = null;

        // To handle wrap-around, create an extended version of horizonData
        const extendedHorizonData = [...horizonData];
        if (horizonData.length > 0) {
            extendedHorizonData.push({ ...horizonData[0], azimuth: horizonData[0].azimuth + 360 });
            extendedHorizonData.unshift({ ...horizonData[horizonData.length - 1], azimuth: horizonData[horizonData.length - 1].azimuth - 360 });
        }

        // Find the two horizon data points that bracket the target azimuth
        for (let i = 0; i < extendedHorizonData.length - 1; i++) {
            const currentPoint = extendedHorizonData[i];
            const nextPoint = extendedHorizonData[i + 1];

            let az1 = currentPoint.azimuth;
            let az2 = nextPoint.azimuth;

            if (targetAzimuthNormalized >= az1 && targetAzimuthNormalized <= az2) {
                p1 = currentPoint;
                p2 = nextPoint;
                break;
            }
        }

        if (p1 && p2) {
            let p1_az_for_interp = p1.azimuth;
            let p2_az_for_interp = p2.azimuth;

            if (p1_az_for_interp > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            let targetAz_for_ratio = targetAzimuthNormalized;
            if (targetAz_for_ratio < p1_az_for_interp && p1_az_for_interp > (p2_az_for_interp - 360)) {
                targetAz_for_ratio += 360;
            }

            if (p2_az_for_interp === p1_az_for_interp) { // Avoid division by zero for vertical segments
                return { lat: p1.horizonLat, lon: p1.horizonLon, azimuth: azimuth };
            }

            const ratio = (targetAz_for_ratio - p1.altitude) / (p2.altitude - p1.altitude); // Interpolate based on azimuth here

            const interpolatedLat = p1.horizonLat + ratio * (p2.horizonLat - p1.horizonLat);
            const interpolatedLon = p1.horizonLon + ratio * (p2.horizonLon - p1.horizonLon);

            return { lat: interpolatedLat, lon: interpolatedLon, azimuth: azimuth };
        }
        return null;
    }

    /**
     * Collects horizon data points that lie azimuthally between two given azimuths,
     * always traversing in a *clockwise (increasing azimuth)* direction, handling 0/360 wrap-around.
     * The points are returned sorted by increasing azimuth.
     * @param {number} startAz - The starting azimuth of the segment (exclusive).
     * @param {number} endAz - The ending azimuth of the segment (exclusive).
     * @param {Array<Object>} horizonData - The full sorted horizon data.
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs for points within the range, ordered by increasing azimuth.
     */
    function getIntermediateHorizonPoints(startAz, endAz, horizonData) {
        const points = [];
        if (!horizonData || horizonData.length === 0) {
            return points;
        }

        // Normalize start and end to be within 0-360 for initial range comparison
        const nStart = normalizeAzimuth(startAz);
        let nEnd = normalizeAzimuth(endAz);

        // If the intended clockwise range crosses 0/360 (e.g., from 350 to 10), adjust nEnd to be > nStart
        if (nStart > nEnd) {
            nEnd += 360; // Treat as 350 to 370 for comparison
        }

        // Create an extended version of horizonData with azimuths adjusted to cover the full 0-720 range
        // This simplifies range checking for wrapped segments.
        const extendedHorizonData = [];
        horizonData.forEach(p => {
            extendedHorizonData.push(p); // Original
            extendedHorizonData.push({ ...p, azimuth: p.azimuth + 360 }); // Add a +360 counterpart
        });
        // Sort the extended data to ensure iteration is always in increasing azimuth order
        extendedHorizonData.sort((a, b) => a.azimuth - b.azimuth);

        // Iterate through the extended, sorted data
        for (const point of extendedHorizonData) {
            const currentAz = point.azimuth;

            // Include points strictly between start and end (exclusive of endpoints)
            // Use a small tolerance for floating-point comparisons
            if (currentAz > nStart + 0.0001 && currentAz < nEnd - 0.0001) {
                if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                    points.push([point.horizonLat, point.horizonLon]);
                }
            }
        }
        return points;
    }

    /**
     * Draws the viewshed horizon as a polyline using provided lat/lon values.
     * @param {Array<Object>} horizonData - Array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @returns {L.Polyline|null} The created Leaflet Polyline object, or null if invalid data.
     */
    function drawViewshedHorizonLine(horizonData) {
        if (!horizonData || horizonData.length === 0) return null;

        const polylinePoints = [];
        horizonData.forEach(point => {
            if (!isNaN(point.horizonLat) && !isNaN(point.horizonLon)) {
                polylinePoints.push([point.horizonLat, point.horizonLon]);
            } else {
                // console.warn(`Skipping point (Azimuth: ${point.azimuth}) due to invalid horizonLat/Lon values. This point will not be part of the drawn viewshed polyline.`); // Removed log
            }
        });

        if (polylinePoints.length >= 2) {
            // Close the polyline by adding the first point again at the end, if not already closed
            const firstPoint = polylinePoints[0];
            const lastPoint = polylinePoints[polylinePoints.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                polylinePoints.push(firstPoint);
            }
            return L.polyline(polylinePoints, {
                color: '#4299e1', // Blue color for the viewshed horizon line
                weight: 2,
                opacity: 0.7,
                smoothFactor: 1
            });
        } else {
            return null;
        }
    }

    /**
     * Draws an individual circle marker on the map for a calculated point.
     * @param {object} point - Object with lat, lon, azimuth properties.
     * @param {string} label - Label for the popup.
     * @param {string} color - The color for the marker (e.g., 'red', 'blue', 'orange').
     * @returns {L.CircleMarker|null} The created Leaflet CircleMarker object, or null if invalid point data.
     */
    function drawIndividualPointMarker(point, label, color = 'orange') {
        if (!map || !point || isNaN(point.lat) || isNaN(point.lon) || isNaN(point.azimuth)) {
            return null;
        }

        const marker = L.circleMarker([point.lat, point.lon], {
            radius: 6,
            fillColor: color, // Use provided color
            color: color, // Use provided color for outline
            weight: 2,
            opacity: 1,
            fillOpacity: 0.25 // 25% fill
        });
        marker.bindPopup(`<b>${label}</b><br>Azimuth: ${point.azimuth.toFixed(3)}Â°<br>Lat: ${point.lat.toFixed(6)}<br>Lon: ${point.lon.toFixed(6)}`);
        return marker;
    }

    /**
     * Converts degrees to radians.
     * @param {number} deg - Degrees.
     * @returns {number} Radians.
     */
    function toRadians(deg) {
        return deg * Math.PI / 180;
    }

    /**
     * Converts radians to degrees.
     * @param {number} rad - Radians.
     * @returns {number} Degrees.
     */
    function toDegrees(rad) {
        return rad * 180 / Math.PI;
    }

    /**
     * Normalizes an azimuth to be within the 0-360 degree range.
     * @param {number} az - Azimuth in degrees.
     * @returns {number} Normalized azimuth in degrees (0-360).
     */
    function normalizeAzimuth(az) {
        return (az % 360 + 360) % 360;
    }

    /**
     * Finds the true rise/set azimuth by locating the point on the viewshed horizon
     * whose apparent altitude matches the celestial body's target apparent altitude.
     * This uses a direct search through horizon segments for a matching altitude.
     * @param {Array<Object>} horizonData - An array of {azimuth, altitude, horizonLat, horizonLon} objects.
     * @param {number} targetApparentAltitude - The precise target apparent altitude (of the celestial body's center) that the viewshed horizon must match.
     * @param {number} initialAzimuthGuess - The scenario-specific initial 0-horizon azimuth guess (e.g., UL, Center, LL azimuth for a flat horizon).
     * @param {string} scenarioName - A descriptive name for the current calculation scenario (e.g., "Upper Limb").
     * @param {number} observerLat - The observer's latitude, used as a fallback for point generation.
     * @param {number} observerLon - The observer's longitude, used as a fallback for point generation.
     * @returns {{azimuth: number|null, lat: number|null, lon: number|null}} The calculated azimuth and its corresponding horizon Lat/Lon, or null if no matching azimuth found.
     */
    async function findActualAzimuthForTargetApparentAltitude(
        horizonData,
        targetApparentAltitude,
        initialAzimuthGuess, // This is now the scenario-specific initial guess
        scenarioName,
        observerLat, // Added observerLat
        observerLon // Added observerLon
    ) {
        const TOLERANCE_ALTITUDE = 0.001; // degrees, for matching altitude

        function setScenarioStatus(message, type = 'status') {
            // console.log(`Display Message [${type}]: ${message}`); // Removed log
        }
        setScenarioStatus(`Calculating ${scenarioName}...`, 'status');

        // initialAzimuthGuess is already a number from Script A's global variables
        let safeInitialAzimuthGuess = initialAzimuthGuess; // No parseFloat needed here
        if (isNaN(safeInitialAzimuthGuess)) {
            console.error(`ERROR: initialAzimuthGuess for ${scenarioName} is not a valid number: ${initialAzimuthGuess}`);
            setScenarioStatus(`${scenarioName}: Error: Invalid initial azimuth.`, 'error');
            return null;
        }

        let minHorizonAlt = Infinity;
        let maxHorizonAlt = -Infinity;

        if (horizonData.length > 0) {
            for (const point of horizonData) {
                if (point.altitude < minHorizonAlt) minHorizonAlt = point.altitude;
                if (point.altitude > maxHorizonAlt) maxHorizonAlt = point.altitude;
            }
        } else {
            console.error(`findActualAzimuthForTargetApparentAltitude (${scenarioName}): Empty horizonData received.`);
            setScenarioStatus(`${scenarioName}: Error: Empty horizon data.`, 'error');
            return null;
        }

        // --- Check if celestial object clears all terrain or is always blocked ---
        if (targetApparentAltitude < minHorizonAlt - TOLERANCE_ALTITUDE) {
            setScenarioStatus(`${scenarioName}: Object clears all terrain. Result is initial 0-Horizon Azimuth.`, 'warn');
            // For this case, we need to provide a dummy lat/lon for the map line to extend
            const dummyPoint = getInterpolatedHorizonLatLon(safeInitialAzimuthGuess, horizonData);
            return { azimuth: safeInitialAzimuthGuess, lat: dummyPoint?.lat, lon: dummyPoint?.lon };
        }
        if (targetApparentAltitude > maxHorizonAlt + TOLERANCE_ALTITUDE) {
            setScenarioStatus(`${scenarioName}: Object is always blocked by terrain. No true event azimuth.`, 'error');
            return null;
        }

        const candidatePoints = []; // Stores {azimuth, lat, lon} for candidates

        // Iterate through all segments of the horizon data to find crossing points
        for (let i = 0; i < horizonData.length; i++) {
            let p1 = horizonData[i];
            let p2 = horizonData[(i + 1) % horizonData.length]; // Wrap around for the last segment

            // Normalize azimuths for linear interpolation
            let p1_az_norm = normalizeAzimuth(p1.azimuth);
            let p2_az_norm = normalizeAzimuth(p2.azimuth);

            // Adjust p2's azimuth to be greater than p1's if it crosses 0/360 boundary for interpolation
            let p2_az_for_interp = p2_az_norm;
            if (p1_az_norm > p2_az_for_interp) {
                p2_az_for_interp += 360;
            }

            // Check if target altitude falls within the range of altitudes for this segment
            const altitudeCrosses = (targetApparentAltitude >= p1.altitude && targetApparentAltitude <= p2.altitude) ||
                (targetApparentAltitude <= p1.altitude && targetApparentAltitude >= p2.altitude);

            if (altitudeCrosses) {
                let interpolatedAzimuth;
                let interpolatedLat;
                let interpolatedLon;

                // Check if one of the endpoints is already at the target altitude within tolerance
                if (Math.abs(p1.altitude - targetApparentAltitude) < TOLERANCE_ALTITUDE) {
                    interpolatedAzimuth = p1_az_norm;
                    interpolatedLat = p1.horizonLat;
                    interpolatedLon = p1.horizonLon;
                } else if (Math.abs(p2.altitude - targetApparentAltitude) < TOLERANCE_ALTITUDE) {
                    interpolatedAzimuth = p2_az_norm;
                    interpolatedLat = p2.horizonLat;
                    interpolatedLon = p2.horizonLon;
                } else if (Math.abs(p2.altitude - p1.altitude) > TOLERANCE_ALTITUDE * 10) { // Avoid division by very small number or zero
                    const ratio = (targetApparentAltitude - p1.altitude) / (p2.altitude - p1.altitude);
                    interpolatedAzimuth = p1_az_for_interp + ratio * (p2_az_for_interp - p1_az_for_interp);
                    interpolatedLat = p1.horizonLat + ratio * (p2.horizonLat - p1.horizonLat);
                    interpolatedLon = p1.horizonLon + ratio * (p2.horizonLon - p1.horizonLon);
                } else {
                    // Segment is almost flat and at target altitude, or very close. Use midpoint.
                    interpolatedAzimuth = (p1_az_norm + p2_az_for_interp) / 2;
                    interpolatedLat = (p1.horizonLat + p2.horizonLat) / 2;
                    interpolatedLon = (p1.horizonLon + p2.horizonLon) / 2;
                }
                candidatePoints.push({ azimuth: normalizeAzimuth(interpolatedAzimuth), lat: interpolatedLat, lon: interpolatedLon });
            }
        }

        if (candidatePoints.length === 0) {
            // Fallback to the point on the horizon closest in altitude, if no direct crossing found.
            let closestAltitudeDiff = Infinity;
            let bestFallbackPoint = null;
            let minAngularDifferenceForFallback = Infinity; // Track angular difference for fallback choice
            for (const point of horizonData) {
                const diff = Math.abs(point.altitude - targetApparentAltitude);

                let angularDiffFromGuess = Math.abs(point.azimuth - safeInitialAzimuthGuess);
                if (angularDiffFromGuess > 180) angularDiffFromGuess = 360 - angularDiffFromGuess; // Shortest angular diff

                // If current point is closer in altitude, or equally close in altitude AND closer angularly to initial guess
                if (diff < closestAltitudeDiff || (diff === closestAltitudeDiff && angularDiffFromGuess < minAngularDifferenceForFallback)) {
                    closestAltitudeDiff = diff;
                    bestFallbackPoint = point;
                    minAngularDifferenceForFallback = angularDiffFromGuess;
                }
            }
            if (bestFallbackPoint !== null) {
                setScenarioStatus(`${scenarioName}: No direct crossing. Closest terrain match found.`, 'warn');
                return { azimuth: normalizeAzimuth(bestFallbackPoint.azimuth), lat: bestFallbackPoint.horizonLat, lon: bestFallbackPoint.horizonLon };
            }
            console.error(`Critical (${scenarioName}): No valid candidate or fallback azimuth found.`);
            setScenarioStatus(`${scenarioName}: Critical error. No match found.`, 'error');
            return null;
        }

        // Find the candidate point that is closest to the scenario's initial 0-horizon guess
        let bestActualPoint = null;
        let minAngularDifference = Infinity;

        candidatePoints.forEach(p => {
            let diff = Math.abs(p.azimuth - safeInitialAzimuthGuess);
            if (diff > 180) diff = 360 - diff; // Correctly calculate shortest angular difference

            if (diff < minAngularDifference) {
                minAngularDifference = diff;
                bestActualPoint = p;
            }
        });

        if (bestActualPoint === null) {
            console.error(`Internal error (${scenarioName}): Candidate azimuths found but no best match selected from candidates.`);
            setScenarioStatus(`${scenarioName}: Internal error.`, 'error');
            return null;
        }

        // Final validation before returning
        if (isNaN(bestActualPoint.lat) || isNaN(bestActualPoint.lon)) {
            console.error(`Calculated point for ${scenarioName} has NaN coordinates (lat: ${bestActualPoint.lat}, lon: ${bestActualPoint.lon}). Returning null.`);
            setScenarioStatus(`${scenarioName}: Calculation resulted in invalid coordinates.`, 'error');
            return null;
        }

        setScenarioStatus(`${scenarioName}: Actual Azimuth calculated.`, 'success');
        return bestActualPoint;
    }

    /**
     * Fetches location data (lat, lon, elev_amsl) for a specific ID from heywhatsthat.com's result.json.
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<{latitude: number, longitude: number, elevation_amsl: number}|null>} Parsed location info.
     */
    async function fetchLocationData(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/bin/result.json?id=${hwtId}`;

        window.displayMessage('locationStatus', `Fetching location data for ID: ${hwtId} from /bin/result.json...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const json = JSON.parse(text);

            const lat = parseFloat(json?.lat);
            const lon = parseFloat(json?.lon);
            const elev_amsl = parseFloat(json?.elev_amsl);

            if (!isNaN(lat) && !isNaN(lon) && !isNaN(elev_amsl)) {
                window.displayMessage('locationStatus', 'Location data fetched successfully.', 'success-message');
                return { latitude: lat, longitude: lon, elevation_amsl: elev_amsl };
            }
            throw new Error("Missing or invalid 'lat', 'lon', or 'elev_amsl' in JSON response.");

        } catch (error) {
            window.displayMessage('locationStatus', 'Error fetching location data.', 'error-message');
            window.displayMessage('locationError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching location data:", error);
            return null;
        }
    }

    /**
     * Fetches and parses viewshed data from heywhatsthat.com's horizon.csv API.
     * @param {string} hwtId - The HeyWhatsThat identifier.
     * @returns {Promise<Array<Object>>} A promise resolving to an array of {azimuth, altitude, horizonLat?, horizonLon?} objects.
     */
    async function fetchHorizonDataHoriZONE(hwtId) {
        const apiUrl = `https://www.heywhatsthat.com/api/horizon.csv?id=${hwtId}&resolution=.125&src=${HWT_HORIZONE_SRC}&keep=1`;

        window.displayMessage('viewshedStatus', `Fetching viewshed data for ID: ${hwtId} from /api/horizon.csv (horiZONE method)...`, 'status-message');
        try {
            const response = await fetch(apiUrl);
            const text = await response.text();

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} - ${text.substring(0, 100)}...`);
            }

            const lines = text.trim().split('\n');
            const horizonData = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#') || line === '') continue;

                const parts = line.split(',').map(s => s.trim());
                // Expecting at least Azimuth (0), Altitude (1), Distance (2), Slope (3), Latitude (4), Longitude (5) - 6 columns
                if (parts.length >= 6) {
                    const azimuth = parseFloat(parts[0]);
                    const altitude = parseFloat(parts[1]);
                    const horizonLat = parseFloat(parts[4]); // 5th column (index 4)
                    const horizonLon = parseFloat(parts[5]); // 6th column (index 5)

                    if (!isNaN(azimuth) && !isNaN(altitude) && !isNaN(horizonLat) && !isNaN(horizonLon)) {
                        horizonData.push({ azimuth, altitude, horizonLat, horizonLon });
                    } else {
                        // console.warn(`Skipping line ${i} due to invalid number parsing (az:${parts[0]}, alt:${parts[1]}, lat:${parts[4]}, lon:${parts[5]}): ${line}`); // Removed log
                    }
                } else {
                    // console.warn(`Skipping line ${i} due to insufficient columns (${parts.length} < 6): ${line}`); // Removed log
                }
            }

            if (horizonData.length === 0) {
                throw new Error("No valid azimuth-altitude-lat-lon pairs parsed from horizon.csv. Response might be malformed or empty data.");
            }

            horizonData.sort((a, b) => a.azimuth - b.azimuth);
            window.displayMessage('viewshedStatus', 'Viewshed data fetched successfully.', 'success-message');
            return horizonData;

        } catch (error) {
            window.displayMessage('viewshedStatus', 'Error fetching viewshed data.', 'error-message');
            window.displayMessage('viewshedError', `Error: ${error.message}`, 'error-error');
            console.error("Error fetching viewshed data:", error);
            return null;
        }
    }

    // Helper function to create and add a polygon layer group
    async function createAndAddPolygonLayer(
        initialAzimuthUL, initialAzimuthCenter, initialAzimuthLL,
        targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
        horizonData, locationData, polygonColor, scenarioName, layerGroupName
    ) {
        const observerLatLng = [locationData.latitude, locationData.longitude];
        // Ensure initialAzimuthUL is a number before comparison
        const isSunriseLike = (parseFloat(initialAzimuthUL) >= 0 && parseFloat(initialAzimuthUL) <= 180);
        const shiftDirectionFactor = isSunriseLike ? 1 : -1;

        const actualPointUL = await findActualAzimuthForTargetApparentAltitude(
            horizonData, targetAltitudeUL, initialAzimuthUL, `${scenarioName} Upper Limb at Horizon`, locationData.latitude, locationData.longitude
        );
        const actualPointCenter = await findActualAzimuthForTargetApparentAltitude(
            horizonData, targetAltitudeCenter, initialAzimuthCenter, `${scenarioName} Center at Horizon`, locationData.latitude, locationData.longitude
        );
        const actualPointLL = await findActualAzimuthForTargetApparentAltitude(
            horizonData, targetAltitudeLL, initialAzimuthLL, `${scenarioName} Lower Limb at Horizon`, locationData.latitude, locationData.longitude
        );

        let layerGroup = L.layerGroup();
        layerGroup.layerNameForControl = layerGroupName; // Store name for layers control

        let anyPointMissing = !(actualPointUL && actualPointCenter && actualPointLL);
        if (anyPointMissing) {
            // console.warn(`Cannot draw ${scenarioName} polygon: one or more critical points are missing.`); // Removed log
            return { layerGroup: layerGroup, success: false };
        }

        const polygonLatLngs = [];
        polygonLatLngs.push(observerLatLng);

        // Add UL point
        polygonLatLngs.push([actualPointUL.lat, actualPointUL.lon]);
        // console.log(`Adding ${scenarioName} UL point to polygon: ${actualPointUL.lat.toFixed(6)}, ${actualPointUL.lon.toFixed(6)}`); // Removed log

        // Add intermediate points between UL and Center
        let pointsBetweenULCenter;
        if (isSunriseLike) {
            pointsBetweenULCenter = getIntermediateHorizonPoints(actualPointUL.azimuth, actualPointCenter.azimuth, horizonData);
            // pointsBetweenULCenter.forEach(p => { console.log(`Adding intermediate point (${scenarioName} UL-Center): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed log
        } else { // Sunset-like, traverse counter-clockwise for intermediate points
            pointsBetweenULCenter = getIntermediateHorizonPoints(actualPointCenter.azimuth, actualPointUL.azimuth, horizonData);
            // pointsBetweenULCenter.reverse().forEach(p => { console.log(`Adding intermediate point (${scenarioName} UL-Center, reversed): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed log
        }
        pointsBetweenULCenter.forEach(p => polygonLatLngs.push(p)); // Add points to polygon

        // Add Center point
        polygonLatLngs.push([actualPointCenter.lat, actualPointCenter.lon]);
        // console.log(`Adding ${scenarioName} Center point to polygon: ${actualPointCenter.lat.toFixed(6)}, ${actualPointCenter.lon.toFixed(6)}`); // Removed log

        // Add intermediate points between Center and LL
        let pointsBetweenCenterLL;
        if (isSunriseLike) {
            pointsBetweenCenterLL = getIntermediateHorizonPoints(actualPointCenter.azimuth, actualPointLL.azimuth, horizonData);
            // pointsBetweenCenterLL.forEach(p => { console.log(`Adding intermediate point (${scenarioName} Center-LL): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed log
        } else { // Sunset-like, traverse counter-clockwise for intermediate points
            pointsBetweenCenterLL = getIntermediateHorizonPoints(actualPointLL.azimuth, actualPointCenter.azimuth, horizonData);
            // pointsBetweenCenterLL.reverse().forEach(p => { console.log(`Adding intermediate point (${scenarioName} Center-LL, reversed): ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`); }); // Removed log
        }
        pointsBetweenCenterLL.forEach(p => polygonLatLngs.push(p)); // Add points to polygon

        // Add LL point
        polygonLatLngs.push([actualPointLL.lat, actualPointLL.lon]);
        // console.log(`Adding ${scenarioName} LL point to polygon: ${actualPointLL.lat.toFixed(6)}, ${actualPointLL.lon.toFixed(6)}`); // Removed log

        polygonLatLngs.push(observerLatLng); // Close the polygon

        const polygon = L.polygon(polygonLatLngs, {
            color: polygonColor,
            weight: 2,
            opacity: 1,
            dashArray: '5, 10',
            fillColor: polygonColor,
            fillOpacity: 0.1
        });
        layerGroup.addLayer(polygon);

        // Add individual markers to the layer group
        layerGroup.addLayer(drawIndividualPointMarker(actualPointUL, `${scenarioName} Upper Limb`, polygonColor));
        layerGroup.addLayer(drawIndividualPointMarker(actualPointCenter, `${scenarioName} Center`, polygonColor));
        layerGroup.addLayer(drawIndividualPointMarker(actualPointLL, `${scenarioName} Lower Limb`, polygonColor));

        // Add the layer group to the map and layers control
        window.map.addLayer(layerGroup);
        window.layersControl.addOverlay(layerGroup, layerGroupName);
        window.scriptCOverlayGroups.push(layerGroup); // Add to Script C's managed layers

        return { layerGroup: layerGroup, success: true };
    }


    // --- Event Listener for Form Submission ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Assign global map and layersControl from Script B once DOM is ready
        map = window.map;
        layersControl = window.layersControl;
        observerMarker = window.bigMarker; // Script B's draggable marker

        const form = document.getElementById('azimuthForm');
        const hwtIdentifierInput = document.getElementById('hwtIdentifierInput');
        // Removed saveGeoJsonButton, importGeoJsonInput, importGeoJsonButton, importStatusDiv
        const loadingSpinner = document.getElementById('loadingSpinner');

        form.addEventListener('submit', async (e) => {
            e.preventDefault(); // Prevent default form submission behavior (page reload)

            window.clearResultsDisplay(); // Use global clearResultsDisplay
            window.displayMessage('overallStatus', 'Starting terrain-adjusted azimuth calculation...', 'status');
            if (loadingSpinner) loadingSpinner.classList.remove('hidden');

            const hwtId = hwtIdentifierInput.value.trim();

            if (!hwtId) {
                window.displayMessage('overallStatus', 'Error: Please enter a HeyWhatsThat Identifier.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return; // Exit early if hwtId is empty
            }

            let locationData = null;
            let horizonData = null;
            let anyCalculationFailed = false;

            // --- Fetch Location Data ---
            locationData = await fetchLocationData(hwtId);
            if (!locationData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch location data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // Update Script B's map and marker with fetched location data
            // This is for visual consistency, not for calculation input in Script C.
            if (map && observerMarker) {
                map.setView([locationData.latitude, locationData.longitude], map.getZoom());
                observerMarker.setLatLng([locationData.latitude, locationData.longitude]);
                document.getElementById('latbox').value = locationData.latitude;
                document.getElementById('lngbox').value = locationData.longitude;
                observerMarker.bindPopup(`<b>Observer Location</b><br>Lat: ${locationData.latitude.toFixed(4)}, Lon: ${locationData.longitude.toFixed(4)}`).openPopup();
            } else {
                console.error("Leaflet map or observer marker not available from Script B.");
                window.displayMessage('overallStatus', 'Error: Map components not ready.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- Fetch Viewshed Data ---
            horizonData = await fetchHorizonDataHoriZONE(hwtId);
            if (!horizonData) {
                window.displayMessage('overallStatus', 'Calculation failed: Could not fetch viewshed data.', 'error');
                if (loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            // --- Calculate Target Apparent Altitudes for the events ---
            const targetAltitudeUL = TARGET_APPARENT_ALTITUDE_SUN_UPPER_LIMB_AT_HORIZON;
            const targetAltitudeCenter = TARGET_APPARENT_ALTITUDE_SUN_CENTER_AT_HORIZON;
            const targetAltitudeLL = TARGET_APPARENT_ALTITUDE_SUN_LOWER_LIMB_AT_HORIZON;

            window.displayMessage('overallStatus', "Calculating actual azimuths...", 'status');

            // --- Viewshed Horizon Line ---
            const viewshedPolyline = drawViewshedHorizonLine(horizonData);
            if (viewshedPolyline) {
                let viewshedHorizonLineGroup = L.layerGroup();
                viewshedHorizonLineGroup.addLayer(viewshedPolyline);
                viewshedHorizonLineGroup.layerNameForControl = "Viewshed Horizon"; // Name for layers control
                window.map.addLayer(viewshedHorizonLineGroup);
                window.layersControl.addOverlay(viewshedHorizonLineGroup, viewshedHorizonLineGroup.layerNameForControl);
                window.scriptCOverlayGroups.push(viewshedHorizonLineGroup);
            }

            // --- Read Mapped Azimuth Values from Script A's Global Variables ---
            // These values are now correctly read directly from the global JavaScript variables
            // that Script A populates. NO .value or parseFloat needed here.
            const wsrZeroHorizonAzimuth = window.solsticeaziwinrise;
            const wssZeroHorizonAzimuth = window.solsticeaziwinset;
            const ssrZeroHorizonAzimuth = window.solsticeazisumrise;
            const sssZeroHorizonAzimuth = window.solsticeazisumset;
            const ncqrZeroHorizonAzimuth = window.crossquarterazisumrise;
            const scqrZeroHorizonAzimuth = window.crossquarteraziwinrise;
            const ncqsZeroHorizonAzimuth = window.crossquarterazisumset;
            const scqsZeroHorizonAzimuth = window.crossquarteraziwinset;
            const nmlrZeroHorizonAzimuth = window.majorazisumrise;
            const nmlsZeroHorizonAzimuth = window.majorazisumset;
            const smlrZeroHorizonAzimuth = window.majoraziwinrise;
            const smlsZeroHorizonAzimuth = window.majoraziwinset;
            const nmnlrZeroHorizonAzimuth = window.minorazisumrise;
            const smnlrZeroHorizonAzimuth = window.minoraziwinrise;
            const nmnlsZeroHorizonAzimuth = window.minorazisumset;
            const smnlsZeroHorizonAzimuth = window.minoraziwinset;
            const erZeroHorizonAzimuth = window.equinoxazisumrise;
            const esZeroHorizonAzimuth = window.equinoxazisumset;
            // --- END MAPPED AZIMUTH VALUES ---

            // --- Process each astronomical event using the helper function ---
            // Changed let to var for result variables to avoid re-declaration errors on subsequent submissions
            var wsrResult = await createAndAddPolygonLayer(
                wsrZeroHorizonAzimuth,
                normalizeAzimuth(wsrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(wsrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[0], "WSR", "Winter Solstice Rise"
            );
            if (!wsrResult.success) anyCalculationFailed = true;

            var wssResult = await createAndAddPolygonLayer(
                wssZeroHorizonAzimuth,
                normalizeAzimuth(wssZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(wssZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[0], "WSS", "Winter Solstice Set"
            );
            if (!wssResult.success) anyCalculationFailed = true;

            var ssrResult = await createAndAddPolygonLayer(
                ssrZeroHorizonAzimuth,
                normalizeAzimuth(ssrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(ssrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[0], "SSR", "Summer Solstice Rise"
            );
            if (!ssrResult.success) anyCalculationFailed = true;

            var sssResult = await createAndAddPolygonLayer(
                sssZeroHorizonAzimuth,
                normalizeAzimuth(sssZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(sssZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[0], "SSS", "Summer Solstice Set"
            );
            if (!sssResult.success) anyCalculationFailed = true;

            var ncqrResult = await createAndAddPolygonLayer(
                ncqrZeroHorizonAzimuth,
                normalizeAzimuth(ncqrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(ncqrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[4], "NCQR", "North Cross-Quarter Rise"
            );
            if (!ncqrResult.success) anyCalculationFailed = true;

            var scqrResult = await createAndAddPolygonLayer(
                scqrZeroHorizonAzimuth,
                normalizeAzimuth(scqrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(scqrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[4], "SCQR", "South Cross-Quarter Rise"
            );
            if (!scqrResult.success) anyCalculationFailed = true;

            var ncqsResult = await createAndAddPolygonLayer(
                ncqsZeroHorizonAzimuth,
                normalizeAzimuth(ncqsZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(ncqsZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[4], "NCQS", "North Cross-Quarter Set"
            );
            if (!ncqsResult.success) anyCalculationFailed = true;

            var scqsResult = await createAndAddPolygonLayer(
                scqsZeroHorizonAzimuth,
                normalizeAzimuth(scqsZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(scqsZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[4], "SCQS", "South Cross-Quarter Set"
            );
            if (!scqsResult.success) anyCalculationFailed = true;

            var nmlrResult = await createAndAddPolygonLayer(
                nmlrZeroHorizonAzimuth,
                normalizeAzimuth(nmlrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(nmlrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[1], "NMLR", "North Major Lunar Rise"
            );
            if (!nmlrResult.success) anyCalculationFailed = true;

            var nmlsResult = await createAndAddPolygonLayer(
                nmlsZeroHorizonAzimuth,
                normalizeAzimuth(nmlsZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(nmlsZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[1], "NMLS", "North Major Lunar Set"
            );
            if (!nmlsResult.success) anyCalculationFailed = true;

            var smlrResult = await createAndAddPolygonLayer(
                smlrZeroHorizonAzimuth,
                normalizeAzimuth(smlrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(smlrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[1], "SMLR", "South Major Lunar Rise"
            );
            if (!smlrResult.success) anyCalculationFailed = true;

            var smnlsResult = await createAndAddPolygonLayer( // Corrected from smlsResult to smnlsResult
                smnlsZeroHorizonAzimuth,
                normalizeAzimuth(smnlsZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(smnlsZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[1], "SMLS", "South Major Lunar Set"
            );
            if (!smnlsResult.success) anyCalculationFailed = true;

            var nmnlrResult = await createAndAddPolygonLayer(
                nmnlrZeroHorizonAzimuth,
                normalizeAzimuth(nmnlrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(nmnlrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[2], "NMnLR", "North Minor Lunar Rise"
            );
            if (!nmnlrResult.success) anyCalculationFailed = true;

            var smnlrResult = await createAndAddPolygonLayer(
                smnlrZeroHorizonAzimuth,
                normalizeAzimuth(smnlrZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(smnlrZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[2], "SMnLR", "South Minor Lunar Rise"
            );
            if (!smnlrResult.success) anyCalculationFailed = true;

            var nmnlsResult = await createAndAddPolygonLayer(
                nmnlsZeroHorizonAzimuth,
                normalizeAzimuth(nmnlsZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(nmnlsZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[2], "NMnLS", "North Minor Lunar Set"
            );
            if (!nmnlsResult.success) anyCalculationFailed = true;

            var smnlsResult = await createAndAddPolygonLayer(
                smnlsZeroHorizonAzimuth,
                normalizeAzimuth(smnlsZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(smnlsZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[2], "SMnLS", "South Minor Lunar Set"
            );
            if (!smnlsResult.success) anyCalculationFailed = true;

            var erResult = await createAndAddPolygonLayer(
                erZeroHorizonAzimuth,
                normalizeAzimuth(erZeroHorizonAzimuth + (1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(erZeroHorizonAzimuth + (2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[3], "ER", "Equinox Rise"
            );
            if (!erResult.success) anyCalculationFailed = true;

            var esResult = await createAndAddPolygonLayer(
                esZeroHorizonAzimuth,
                normalizeAzimuth(esZeroHorizonAzimuth + (-1 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                normalizeAzimuth(esZeroHorizonAzimuth + (-2 * AZIMUTH_SHIFT_PER_SOLAR_SEMIDIAMETER_UNIT)),
                targetAltitudeUL, targetAltitudeCenter, targetAltitudeLL,
                horizonData, locationData, POLYGON_COLORS[3], "ES", "Equinox Set"
            );
            if (!esResult.success) anyCalculationFailed = true;


            // Adjust map bounds to encompass all drawn elements
            let bounds = new L.LatLngBounds();
            window.scriptCOverlayGroups.forEach(layerGroup => { // Use window.scriptCOverlayGroups
                if (window.map.hasLayer(layerGroup)) {
                    layerGroup.eachLayer(function(subLayer) {
                        if (subLayer.getLatLngs) { // For polygons/polylines
                            bounds.extend(subLayer.getBounds());
                        } else if (subLayer.getLatLng) { // For markers
                            bounds.extend(subLayer.getLatLng());
                        }
                    });
                }
            });

            // Also include the observer marker in the bounds
            if (observerMarker && observerMarker.getLatLng()) {
                bounds.extend(observerMarker.getLatLng());
            }

            if (bounds.isValid()) {
                window.map.fitBounds(bounds, { padding: [50, 50] });
            }

            if (!anyCalculationFailed) {
                window.displayMessage('overallStatus', 'Calculation Complete for all scenarios.', 'success');
            } else {
                window.displayMessage('overallStatus', 'Calculation finished with some scenarios not finding a direct match. Check detailed statuses and console for more info.', 'warn');
            }
            if (loadingSpinner) loadingSpinner.classList.add('hidden');
        });

        // --- GeoJSON Export Functionality (Removed from here, will be in separate script) ---
        // --- GeoJSON Import Functionality (Removed from here, will be in separate script) ---
    });

})();